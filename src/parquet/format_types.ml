(*
 Autogenerated by Thrift Compiler (0.18.1)

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift

module Type = struct
  type t =
    | BOOLEAN
    | INT32
    | INT64
    | INT96
    | FLOAT
    | DOUBLE
    | BYTE_ARRAY
    | FIXED_LEN_BYTE_ARRAY

  let to_i = function
    | BOOLEAN -> 0l
    | INT32 -> 1l
    | INT64 -> 2l
    | INT96 -> 3l
    | FLOAT -> 4l
    | DOUBLE -> 5l
    | BYTE_ARRAY -> 6l
    | FIXED_LEN_BYTE_ARRAY -> 7l

  let of_i = function
    | 0l -> BOOLEAN
    | 1l -> INT32
    | 2l -> INT64
    | 3l -> INT96
    | 4l -> FLOAT
    | 5l -> DOUBLE
    | 6l -> BYTE_ARRAY
    | 7l -> FIXED_LEN_BYTE_ARRAY
    | _ -> raise Thrift_error
end

module ConvertedType = struct
  type t =
    | UTF8
    | MAP
    | MAP_KEY_VALUE
    | LIST
    | ENUM
    | DECIMAL
    | DATE
    | TIME_MILLIS
    | TIME_MICROS
    | TIMESTAMP_MILLIS
    | TIMESTAMP_MICROS
    | UINT_8
    | UINT_16
    | UINT_32
    | UINT_64
    | INT_8
    | INT_16
    | INT_32
    | INT_64
    | JSON
    | BSON
    | INTERVAL

  let to_i = function
    | UTF8 -> 0l
    | MAP -> 1l
    | MAP_KEY_VALUE -> 2l
    | LIST -> 3l
    | ENUM -> 4l
    | DECIMAL -> 5l
    | DATE -> 6l
    | TIME_MILLIS -> 7l
    | TIME_MICROS -> 8l
    | TIMESTAMP_MILLIS -> 9l
    | TIMESTAMP_MICROS -> 10l
    | UINT_8 -> 11l
    | UINT_16 -> 12l
    | UINT_32 -> 13l
    | UINT_64 -> 14l
    | INT_8 -> 15l
    | INT_16 -> 16l
    | INT_32 -> 17l
    | INT_64 -> 18l
    | JSON -> 19l
    | BSON -> 20l
    | INTERVAL -> 21l

  let of_i = function
    | 0l -> UTF8
    | 1l -> MAP
    | 2l -> MAP_KEY_VALUE
    | 3l -> LIST
    | 4l -> ENUM
    | 5l -> DECIMAL
    | 6l -> DATE
    | 7l -> TIME_MILLIS
    | 8l -> TIME_MICROS
    | 9l -> TIMESTAMP_MILLIS
    | 10l -> TIMESTAMP_MICROS
    | 11l -> UINT_8
    | 12l -> UINT_16
    | 13l -> UINT_32
    | 14l -> UINT_64
    | 15l -> INT_8
    | 16l -> INT_16
    | 17l -> INT_32
    | 18l -> INT_64
    | 19l -> JSON
    | 20l -> BSON
    | 21l -> INTERVAL
    | _ -> raise Thrift_error
end

module FieldRepetitionType = struct
  type t = REQUIRED | OPTIONAL | REPEATED

  let to_i = function REQUIRED -> 0l | OPTIONAL -> 1l | REPEATED -> 2l

  let of_i = function
    | 0l -> REQUIRED
    | 1l -> OPTIONAL
    | 2l -> REPEATED
    | _ -> raise Thrift_error
end

module Encoding = struct
  type t =
    | PLAIN
    | PLAIN_DICTIONARY
    | RLE
    | BIT_PACKED
    | DELTA_BINARY_PACKED
    | DELTA_LENGTH_BYTE_ARRAY
    | DELTA_BYTE_ARRAY
    | RLE_DICTIONARY
    | BYTE_STREAM_SPLIT

  let to_i = function
    | PLAIN -> 0l
    | PLAIN_DICTIONARY -> 2l
    | RLE -> 3l
    | BIT_PACKED -> 4l
    | DELTA_BINARY_PACKED -> 5l
    | DELTA_LENGTH_BYTE_ARRAY -> 6l
    | DELTA_BYTE_ARRAY -> 7l
    | RLE_DICTIONARY -> 8l
    | BYTE_STREAM_SPLIT -> 9l

  let of_i = function
    | 0l -> PLAIN
    | 2l -> PLAIN_DICTIONARY
    | 3l -> RLE
    | 4l -> BIT_PACKED
    | 5l -> DELTA_BINARY_PACKED
    | 6l -> DELTA_LENGTH_BYTE_ARRAY
    | 7l -> DELTA_BYTE_ARRAY
    | 8l -> RLE_DICTIONARY
    | 9l -> BYTE_STREAM_SPLIT
    | _ -> raise Thrift_error
end

module CompressionCodec = struct
  type t = UNCOMPRESSED | SNAPPY | GZIP | LZO | BROTLI | LZ4 | ZSTD | LZ4_RAW

  let to_i = function
    | UNCOMPRESSED -> 0l
    | SNAPPY -> 1l
    | GZIP -> 2l
    | LZO -> 3l
    | BROTLI -> 4l
    | LZ4 -> 5l
    | ZSTD -> 6l
    | LZ4_RAW -> 7l

  let of_i = function
    | 0l -> UNCOMPRESSED
    | 1l -> SNAPPY
    | 2l -> GZIP
    | 3l -> LZO
    | 4l -> BROTLI
    | 5l -> LZ4
    | 6l -> ZSTD
    | 7l -> LZ4_RAW
    | _ -> raise Thrift_error
end

module PageType = struct
  type t = DATA_PAGE | INDEX_PAGE | DICTIONARY_PAGE | DATA_PAGE_V2

  let to_i = function
    | DATA_PAGE -> 0l
    | INDEX_PAGE -> 1l
    | DICTIONARY_PAGE -> 2l
    | DATA_PAGE_V2 -> 3l

  let of_i = function
    | 0l -> DATA_PAGE
    | 1l -> INDEX_PAGE
    | 2l -> DICTIONARY_PAGE
    | 3l -> DATA_PAGE_V2
    | _ -> raise Thrift_error
end

module BoundaryOrder = struct
  type t = UNORDERED | ASCENDING | DESCENDING

  let to_i = function UNORDERED -> 0l | ASCENDING -> 1l | DESCENDING -> 2l

  let of_i = function
    | 0l -> UNORDERED
    | 1l -> ASCENDING
    | 2l -> DESCENDING
    | _ -> raise Thrift_error
end

class statistics =
  object (self)
    val mutable _max : string option = None
    method get_max = _max

    method grab_max =
      match _max with
      | None -> raise (Field_empty "statistics.max")
      | Some _x0 -> _x0

    method set_max _x0 = _max <- Some _x0
    method unset_max = _max <- None
    method reset_max = _max <- None
    val mutable _min : string option = None
    method get_min = _min

    method grab_min =
      match _min with
      | None -> raise (Field_empty "statistics.min")
      | Some _x1 -> _x1

    method set_min _x1 = _min <- Some _x1
    method unset_min = _min <- None
    method reset_min = _min <- None
    val mutable _null_count : Int64.t option = None
    method get_null_count = _null_count

    method grab_null_count =
      match _null_count with
      | None -> raise (Field_empty "statistics.null_count")
      | Some _x2 -> _x2

    method set_null_count _x2 = _null_count <- Some _x2
    method unset_null_count = _null_count <- None
    method reset_null_count = _null_count <- None
    val mutable _distinct_count : Int64.t option = None
    method get_distinct_count = _distinct_count

    method grab_distinct_count =
      match _distinct_count with
      | None -> raise (Field_empty "statistics.distinct_count")
      | Some _x3 -> _x3

    method set_distinct_count _x3 = _distinct_count <- Some _x3
    method unset_distinct_count = _distinct_count <- None
    method reset_distinct_count = _distinct_count <- None
    val mutable _max_value : string option = None
    method get_max_value = _max_value

    method grab_max_value =
      match _max_value with
      | None -> raise (Field_empty "statistics.max_value")
      | Some _x4 -> _x4

    method set_max_value _x4 = _max_value <- Some _x4
    method unset_max_value = _max_value <- None
    method reset_max_value = _max_value <- None
    val mutable _min_value : string option = None
    method get_min_value = _min_value

    method grab_min_value =
      match _min_value with
      | None -> raise (Field_empty "statistics.min_value")
      | Some _x5 -> _x5

    method set_min_value _x5 = _min_value <- Some _x5
    method unset_min_value = _min_value <- None
    method reset_min_value = _min_value <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "Statistics";
      (match _max with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("max", Protocol.T_STRING, 1);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _min with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("min", Protocol.T_STRING, 2);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _null_count with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("null_count", Protocol.T_I64, 3);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _distinct_count with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("distinct_count", Protocol.T_I64, 4);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _max_value with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("max_value", Protocol.T_STRING, 5);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _min_value with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("min_value", Protocol.T_STRING, 6);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_statistics (iprot : Protocol.t) =
  let _str8 = new statistics in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t9, _id10 = iprot#readFieldBegin in
       if _t9 = Protocol.T_STOP then raise Break else ();
       (match _id10 with
       | 1 ->
           if _t9 = Protocol.T_STRING then _str8#set_max iprot#readString
           else iprot#skip _t9
       | 2 ->
           if _t9 = Protocol.T_STRING then _str8#set_min iprot#readString
           else iprot#skip _t9
       | 3 ->
           if _t9 = Protocol.T_I64 then _str8#set_null_count iprot#readI64
           else iprot#skip _t9
       | 4 ->
           if _t9 = Protocol.T_I64 then _str8#set_distinct_count iprot#readI64
           else iprot#skip _t9
       | 5 ->
           if _t9 = Protocol.T_STRING then _str8#set_max_value iprot#readString
           else iprot#skip _t9
       | 6 ->
           if _t9 = Protocol.T_STRING then _str8#set_min_value iprot#readString
           else iprot#skip _t9
       | _ -> iprot#skip _t9);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str8

class stringType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "StringType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_stringType (iprot : Protocol.t) =
  let _str14 = new stringType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t15, _id16 = iprot#readFieldBegin in
       if _t15 = Protocol.T_STOP then raise Break else ();
       (match _id16 with _ -> iprot#skip _t15);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str14

class uUIDType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "UUIDType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_uUIDType (iprot : Protocol.t) =
  let _str20 = new uUIDType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t21, _id22 = iprot#readFieldBegin in
       if _t21 = Protocol.T_STOP then raise Break else ();
       (match _id22 with _ -> iprot#skip _t21);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str20

class mapType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "MapType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_mapType (iprot : Protocol.t) =
  let _str26 = new mapType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t27, _id28 = iprot#readFieldBegin in
       if _t27 = Protocol.T_STOP then raise Break else ();
       (match _id28 with _ -> iprot#skip _t27);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str26

class listType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "ListType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_listType (iprot : Protocol.t) =
  let _str32 = new listType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t33, _id34 = iprot#readFieldBegin in
       if _t33 = Protocol.T_STOP then raise Break else ();
       (match _id34 with _ -> iprot#skip _t33);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str32

class enumType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "EnumType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_enumType (iprot : Protocol.t) =
  let _str38 = new enumType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t39, _id40 = iprot#readFieldBegin in
       if _t39 = Protocol.T_STOP then raise Break else ();
       (match _id40 with _ -> iprot#skip _t39);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str38

class dateType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "DateType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_dateType (iprot : Protocol.t) =
  let _str44 = new dateType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t45, _id46 = iprot#readFieldBegin in
       if _t45 = Protocol.T_STOP then raise Break else ();
       (match _id46 with _ -> iprot#skip _t45);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str44

class nullType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "NullType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_nullType (iprot : Protocol.t) =
  let _str50 = new nullType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t51, _id52 = iprot#readFieldBegin in
       if _t51 = Protocol.T_STOP then raise Break else ();
       (match _id52 with _ -> iprot#skip _t51);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str50

class decimalType =
  object (self)
    val mutable _scale : Int32.t option = None
    method get_scale = _scale

    method grab_scale =
      match _scale with
      | None -> raise (Field_empty "decimalType.scale")
      | Some _x54 -> _x54

    method set_scale _x54 = _scale <- Some _x54
    method unset_scale = _scale <- None
    method reset_scale = _scale <- None
    val mutable _precision : Int32.t option = None
    method get_precision = _precision

    method grab_precision =
      match _precision with
      | None -> raise (Field_empty "decimalType.precision")
      | Some _x55 -> _x55

    method set_precision _x55 = _precision <- Some _x55
    method unset_precision = _precision <- None
    method reset_precision = _precision <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "DecimalType";
      (match _scale with
      | None -> raise (Field_empty "decimalType._scale")
      | Some _v ->
          oprot#writeFieldBegin ("scale", Protocol.T_I32, 1);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _precision with
      | None -> raise (Field_empty "decimalType._precision")
      | Some _v ->
          oprot#writeFieldBegin ("precision", Protocol.T_I32, 2);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_decimalType (iprot : Protocol.t) =
  let _str58 = new decimalType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t59, _id60 = iprot#readFieldBegin in
       if _t59 = Protocol.T_STOP then raise Break else ();
       (match _id60 with
       | 1 ->
           if _t59 = Protocol.T_I32 then _str58#set_scale iprot#readI32
           else iprot#skip _t59
       | 2 ->
           if _t59 = Protocol.T_I32 then _str58#set_precision iprot#readI32
           else iprot#skip _t59
       | _ -> iprot#skip _t59);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str58

class milliSeconds =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "MilliSeconds";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_milliSeconds (iprot : Protocol.t) =
  let _str64 = new milliSeconds in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t65, _id66 = iprot#readFieldBegin in
       if _t65 = Protocol.T_STOP then raise Break else ();
       (match _id66 with _ -> iprot#skip _t65);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str64

class microSeconds =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "MicroSeconds";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_microSeconds (iprot : Protocol.t) =
  let _str70 = new microSeconds in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t71, _id72 = iprot#readFieldBegin in
       if _t71 = Protocol.T_STOP then raise Break else ();
       (match _id72 with _ -> iprot#skip _t71);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str70

class nanoSeconds =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "NanoSeconds";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_nanoSeconds (iprot : Protocol.t) =
  let _str76 = new nanoSeconds in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t77, _id78 = iprot#readFieldBegin in
       if _t77 = Protocol.T_STOP then raise Break else ();
       (match _id78 with _ -> iprot#skip _t77);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str76

class timeUnit =
  object (self)
    val mutable _mILLIS : milliSeconds option = None
    method get_mILLIS = _mILLIS

    method grab_mILLIS =
      match _mILLIS with
      | None -> raise (Field_empty "timeUnit.mILLIS")
      | Some _x80 -> _x80

    method set_mILLIS _x80 = _mILLIS <- Some _x80
    method unset_mILLIS = _mILLIS <- None
    method reset_mILLIS = _mILLIS <- None
    val mutable _mICROS : microSeconds option = None
    method get_mICROS = _mICROS

    method grab_mICROS =
      match _mICROS with
      | None -> raise (Field_empty "timeUnit.mICROS")
      | Some _x81 -> _x81

    method set_mICROS _x81 = _mICROS <- Some _x81
    method unset_mICROS = _mICROS <- None
    method reset_mICROS = _mICROS <- None
    val mutable _nANOS : nanoSeconds option = None
    method get_nANOS = _nANOS

    method grab_nANOS =
      match _nANOS with
      | None -> raise (Field_empty "timeUnit.nANOS")
      | Some _x82 -> _x82

    method set_nANOS _x82 = _nANOS <- Some _x82
    method unset_nANOS = _nANOS <- None
    method reset_nANOS = _nANOS <- None

    method copy =
      let _new = Oo.copy self in
      if _mILLIS <> None then _new#set_mILLIS self#grab_mILLIS#copy;
      if _mICROS <> None then _new#set_mICROS self#grab_mICROS#copy;
      if _nANOS <> None then _new#set_nANOS self#grab_nANOS#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "TimeUnit";
      (match _mILLIS with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("MILLIS", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _mICROS with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("MICROS", Protocol.T_STRUCT, 2);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _nANOS with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("NANOS", Protocol.T_STRUCT, 3);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_timeUnit (iprot : Protocol.t) =
  let _str85 = new timeUnit in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t86, _id87 = iprot#readFieldBegin in
       if _t86 = Protocol.T_STOP then raise Break else ();
       (match _id87 with
       | 1 ->
           if _t86 = Protocol.T_STRUCT then
             _str85#set_mILLIS (read_milliSeconds iprot)
           else iprot#skip _t86
       | 2 ->
           if _t86 = Protocol.T_STRUCT then
             _str85#set_mICROS (read_microSeconds iprot)
           else iprot#skip _t86
       | 3 ->
           if _t86 = Protocol.T_STRUCT then
             _str85#set_nANOS (read_nanoSeconds iprot)
           else iprot#skip _t86
       | _ -> iprot#skip _t86);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str85

class timestampType =
  object (self)
    val mutable _isAdjustedToUTC : bool option = None
    method get_isAdjustedToUTC = _isAdjustedToUTC

    method grab_isAdjustedToUTC =
      match _isAdjustedToUTC with
      | None -> raise (Field_empty "timestampType.isAdjustedToUTC")
      | Some _x89 -> _x89

    method set_isAdjustedToUTC _x89 = _isAdjustedToUTC <- Some _x89
    method unset_isAdjustedToUTC = _isAdjustedToUTC <- None
    method reset_isAdjustedToUTC = _isAdjustedToUTC <- None
    val mutable _unit : timeUnit option = None
    method get_unit = _unit

    method grab_unit =
      match _unit with
      | None -> raise (Field_empty "timestampType.unit")
      | Some _x90 -> _x90

    method set_unit _x90 = _unit <- Some _x90
    method unset_unit = _unit <- None
    method reset_unit = _unit <- None

    method copy =
      let _new = Oo.copy self in
      if _unit <> None then _new#set_unit self#grab_unit#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "TimestampType";
      (match _isAdjustedToUTC with
      | None -> raise (Field_empty "timestampType._isAdjustedToUTC")
      | Some _v ->
          oprot#writeFieldBegin ("isAdjustedToUTC", Protocol.T_BOOL, 1);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      (match _unit with
      | None -> raise (Field_empty "timestampType._unit")
      | Some _v ->
          oprot#writeFieldBegin ("unit", Protocol.T_STRUCT, 2);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_timestampType (iprot : Protocol.t) =
  let _str93 = new timestampType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t94, _id95 = iprot#readFieldBegin in
       if _t94 = Protocol.T_STOP then raise Break else ();
       (match _id95 with
       | 1 ->
           if _t94 = Protocol.T_BOOL then
             _str93#set_isAdjustedToUTC iprot#readBool
           else iprot#skip _t94
       | 2 ->
           if _t94 = Protocol.T_STRUCT then
             _str93#set_unit (read_timeUnit iprot)
           else iprot#skip _t94
       | _ -> iprot#skip _t94);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str93

class timeType =
  object (self)
    val mutable _isAdjustedToUTC : bool option = None
    method get_isAdjustedToUTC = _isAdjustedToUTC

    method grab_isAdjustedToUTC =
      match _isAdjustedToUTC with
      | None -> raise (Field_empty "timeType.isAdjustedToUTC")
      | Some _x97 -> _x97

    method set_isAdjustedToUTC _x97 = _isAdjustedToUTC <- Some _x97
    method unset_isAdjustedToUTC = _isAdjustedToUTC <- None
    method reset_isAdjustedToUTC = _isAdjustedToUTC <- None
    val mutable _unit : timeUnit option = None
    method get_unit = _unit

    method grab_unit =
      match _unit with
      | None -> raise (Field_empty "timeType.unit")
      | Some _x98 -> _x98

    method set_unit _x98 = _unit <- Some _x98
    method unset_unit = _unit <- None
    method reset_unit = _unit <- None

    method copy =
      let _new = Oo.copy self in
      if _unit <> None then _new#set_unit self#grab_unit#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "TimeType";
      (match _isAdjustedToUTC with
      | None -> raise (Field_empty "timeType._isAdjustedToUTC")
      | Some _v ->
          oprot#writeFieldBegin ("isAdjustedToUTC", Protocol.T_BOOL, 1);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      (match _unit with
      | None -> raise (Field_empty "timeType._unit")
      | Some _v ->
          oprot#writeFieldBegin ("unit", Protocol.T_STRUCT, 2);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_timeType (iprot : Protocol.t) =
  let _str101 = new timeType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t102, _id103 = iprot#readFieldBegin in
       if _t102 = Protocol.T_STOP then raise Break else ();
       (match _id103 with
       | 1 ->
           if _t102 = Protocol.T_BOOL then
             _str101#set_isAdjustedToUTC iprot#readBool
           else iprot#skip _t102
       | 2 ->
           if _t102 = Protocol.T_STRUCT then
             _str101#set_unit (read_timeUnit iprot)
           else iprot#skip _t102
       | _ -> iprot#skip _t102);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str101

class intType =
  object (self)
    val mutable _bitWidth : int option = None
    method get_bitWidth = _bitWidth

    method grab_bitWidth =
      match _bitWidth with
      | None -> raise (Field_empty "intType.bitWidth")
      | Some _x105 -> _x105

    method set_bitWidth _x105 = _bitWidth <- Some _x105
    method unset_bitWidth = _bitWidth <- None
    method reset_bitWidth = _bitWidth <- None
    val mutable _isSigned : bool option = None
    method get_isSigned = _isSigned

    method grab_isSigned =
      match _isSigned with
      | None -> raise (Field_empty "intType.isSigned")
      | Some _x106 -> _x106

    method set_isSigned _x106 = _isSigned <- Some _x106
    method unset_isSigned = _isSigned <- None
    method reset_isSigned = _isSigned <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "IntType";
      (match _bitWidth with
      | None -> raise (Field_empty "intType._bitWidth")
      | Some _v ->
          oprot#writeFieldBegin ("bitWidth", Protocol.T_BYTE, 1);
          oprot#writeByte _v;
          oprot#writeFieldEnd);
      (match _isSigned with
      | None -> raise (Field_empty "intType._isSigned")
      | Some _v ->
          oprot#writeFieldBegin ("isSigned", Protocol.T_BOOL, 2);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_intType (iprot : Protocol.t) =
  let _str109 = new intType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t110, _id111 = iprot#readFieldBegin in
       if _t110 = Protocol.T_STOP then raise Break else ();
       (match _id111 with
       | 1 ->
           if _t110 = Protocol.T_BYTE then _str109#set_bitWidth iprot#readByte
           else iprot#skip _t110
       | 2 ->
           if _t110 = Protocol.T_BOOL then _str109#set_isSigned iprot#readBool
           else iprot#skip _t110
       | _ -> iprot#skip _t110);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str109

class jsonType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "JsonType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_jsonType (iprot : Protocol.t) =
  let _str115 = new jsonType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t116, _id117 = iprot#readFieldBegin in
       if _t116 = Protocol.T_STOP then raise Break else ();
       (match _id117 with _ -> iprot#skip _t116);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str115

class bsonType =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "BsonType";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_bsonType (iprot : Protocol.t) =
  let _str121 = new bsonType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t122, _id123 = iprot#readFieldBegin in
       if _t122 = Protocol.T_STOP then raise Break else ();
       (match _id123 with _ -> iprot#skip _t122);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str121

class logicalType =
  object (self)
    val mutable _sTRING : stringType option = None
    method get_sTRING = _sTRING

    method grab_sTRING =
      match _sTRING with
      | None -> raise (Field_empty "logicalType.sTRING")
      | Some _x125 -> _x125

    method set_sTRING _x125 = _sTRING <- Some _x125
    method unset_sTRING = _sTRING <- None
    method reset_sTRING = _sTRING <- None
    val mutable _mAP : mapType option = None
    method get_mAP = _mAP

    method grab_mAP =
      match _mAP with
      | None -> raise (Field_empty "logicalType.mAP")
      | Some _x126 -> _x126

    method set_mAP _x126 = _mAP <- Some _x126
    method unset_mAP = _mAP <- None
    method reset_mAP = _mAP <- None
    val mutable _lIST : listType option = None
    method get_lIST = _lIST

    method grab_lIST =
      match _lIST with
      | None -> raise (Field_empty "logicalType.lIST")
      | Some _x127 -> _x127

    method set_lIST _x127 = _lIST <- Some _x127
    method unset_lIST = _lIST <- None
    method reset_lIST = _lIST <- None
    val mutable _eNUM : enumType option = None
    method get_eNUM = _eNUM

    method grab_eNUM =
      match _eNUM with
      | None -> raise (Field_empty "logicalType.eNUM")
      | Some _x128 -> _x128

    method set_eNUM _x128 = _eNUM <- Some _x128
    method unset_eNUM = _eNUM <- None
    method reset_eNUM = _eNUM <- None
    val mutable _dECIMAL : decimalType option = None
    method get_dECIMAL = _dECIMAL

    method grab_dECIMAL =
      match _dECIMAL with
      | None -> raise (Field_empty "logicalType.dECIMAL")
      | Some _x129 -> _x129

    method set_dECIMAL _x129 = _dECIMAL <- Some _x129
    method unset_dECIMAL = _dECIMAL <- None
    method reset_dECIMAL = _dECIMAL <- None
    val mutable _dATE : dateType option = None
    method get_dATE = _dATE

    method grab_dATE =
      match _dATE with
      | None -> raise (Field_empty "logicalType.dATE")
      | Some _x130 -> _x130

    method set_dATE _x130 = _dATE <- Some _x130
    method unset_dATE = _dATE <- None
    method reset_dATE = _dATE <- None
    val mutable _tIME : timeType option = None
    method get_tIME = _tIME

    method grab_tIME =
      match _tIME with
      | None -> raise (Field_empty "logicalType.tIME")
      | Some _x131 -> _x131

    method set_tIME _x131 = _tIME <- Some _x131
    method unset_tIME = _tIME <- None
    method reset_tIME = _tIME <- None
    val mutable _tIMESTAMP : timestampType option = None
    method get_tIMESTAMP = _tIMESTAMP

    method grab_tIMESTAMP =
      match _tIMESTAMP with
      | None -> raise (Field_empty "logicalType.tIMESTAMP")
      | Some _x132 -> _x132

    method set_tIMESTAMP _x132 = _tIMESTAMP <- Some _x132
    method unset_tIMESTAMP = _tIMESTAMP <- None
    method reset_tIMESTAMP = _tIMESTAMP <- None
    val mutable _iNTEGER : intType option = None
    method get_iNTEGER = _iNTEGER

    method grab_iNTEGER =
      match _iNTEGER with
      | None -> raise (Field_empty "logicalType.iNTEGER")
      | Some _x133 -> _x133

    method set_iNTEGER _x133 = _iNTEGER <- Some _x133
    method unset_iNTEGER = _iNTEGER <- None
    method reset_iNTEGER = _iNTEGER <- None
    val mutable _uNKNOWN : nullType option = None
    method get_uNKNOWN = _uNKNOWN

    method grab_uNKNOWN =
      match _uNKNOWN with
      | None -> raise (Field_empty "logicalType.uNKNOWN")
      | Some _x134 -> _x134

    method set_uNKNOWN _x134 = _uNKNOWN <- Some _x134
    method unset_uNKNOWN = _uNKNOWN <- None
    method reset_uNKNOWN = _uNKNOWN <- None
    val mutable _jSON : jsonType option = None
    method get_jSON = _jSON

    method grab_jSON =
      match _jSON with
      | None -> raise (Field_empty "logicalType.jSON")
      | Some _x135 -> _x135

    method set_jSON _x135 = _jSON <- Some _x135
    method unset_jSON = _jSON <- None
    method reset_jSON = _jSON <- None
    val mutable _bSON : bsonType option = None
    method get_bSON = _bSON

    method grab_bSON =
      match _bSON with
      | None -> raise (Field_empty "logicalType.bSON")
      | Some _x136 -> _x136

    method set_bSON _x136 = _bSON <- Some _x136
    method unset_bSON = _bSON <- None
    method reset_bSON = _bSON <- None
    val mutable _uUID : uUIDType option = None
    method get_uUID = _uUID

    method grab_uUID =
      match _uUID with
      | None -> raise (Field_empty "logicalType.uUID")
      | Some _x137 -> _x137

    method set_uUID _x137 = _uUID <- Some _x137
    method unset_uUID = _uUID <- None
    method reset_uUID = _uUID <- None

    method copy =
      let _new = Oo.copy self in
      if _sTRING <> None then _new#set_sTRING self#grab_sTRING#copy;
      if _mAP <> None then _new#set_mAP self#grab_mAP#copy;
      if _lIST <> None then _new#set_lIST self#grab_lIST#copy;
      if _eNUM <> None then _new#set_eNUM self#grab_eNUM#copy;
      if _dECIMAL <> None then _new#set_dECIMAL self#grab_dECIMAL#copy;
      if _dATE <> None then _new#set_dATE self#grab_dATE#copy;
      if _tIME <> None then _new#set_tIME self#grab_tIME#copy;
      if _tIMESTAMP <> None then _new#set_tIMESTAMP self#grab_tIMESTAMP#copy;
      if _iNTEGER <> None then _new#set_iNTEGER self#grab_iNTEGER#copy;
      if _uNKNOWN <> None then _new#set_uNKNOWN self#grab_uNKNOWN#copy;
      if _jSON <> None then _new#set_jSON self#grab_jSON#copy;
      if _bSON <> None then _new#set_bSON self#grab_bSON#copy;
      if _uUID <> None then _new#set_uUID self#grab_uUID#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "LogicalType";
      (match _sTRING with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("STRING", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _mAP with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("MAP", Protocol.T_STRUCT, 2);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _lIST with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("LIST", Protocol.T_STRUCT, 3);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _eNUM with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("ENUM", Protocol.T_STRUCT, 4);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _dECIMAL with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("DECIMAL", Protocol.T_STRUCT, 5);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _dATE with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("DATE", Protocol.T_STRUCT, 6);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _tIME with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("TIME", Protocol.T_STRUCT, 7);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _tIMESTAMP with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("TIMESTAMP", Protocol.T_STRUCT, 8);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _iNTEGER with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("INTEGER", Protocol.T_STRUCT, 10);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _uNKNOWN with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("UNKNOWN", Protocol.T_STRUCT, 11);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _jSON with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("JSON", Protocol.T_STRUCT, 12);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _bSON with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("BSON", Protocol.T_STRUCT, 13);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _uUID with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("UUID", Protocol.T_STRUCT, 14);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_logicalType (iprot : Protocol.t) =
  let _str140 = new logicalType in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t141, _id142 = iprot#readFieldBegin in
       if _t141 = Protocol.T_STOP then raise Break else ();
       (match _id142 with
       | 1 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_sTRING (read_stringType iprot)
           else iprot#skip _t141
       | 2 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_mAP (read_mapType iprot)
           else iprot#skip _t141
       | 3 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_lIST (read_listType iprot)
           else iprot#skip _t141
       | 4 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_eNUM (read_enumType iprot)
           else iprot#skip _t141
       | 5 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_dECIMAL (read_decimalType iprot)
           else iprot#skip _t141
       | 6 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_dATE (read_dateType iprot)
           else iprot#skip _t141
       | 7 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_tIME (read_timeType iprot)
           else iprot#skip _t141
       | 8 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_tIMESTAMP (read_timestampType iprot)
           else iprot#skip _t141
       | 10 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_iNTEGER (read_intType iprot)
           else iprot#skip _t141
       | 11 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_uNKNOWN (read_nullType iprot)
           else iprot#skip _t141
       | 12 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_jSON (read_jsonType iprot)
           else iprot#skip _t141
       | 13 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_bSON (read_bsonType iprot)
           else iprot#skip _t141
       | 14 ->
           if _t141 = Protocol.T_STRUCT then
             _str140#set_uUID (read_uUIDType iprot)
           else iprot#skip _t141
       | _ -> iprot#skip _t141);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str140

class schemaElement =
  object (self)
    val mutable _type : Type.t option = None
    method get_type = _type

    method grab_type =
      match _type with
      | None -> raise (Field_empty "schemaElement.type")
      | Some _x144 -> _x144

    method set_type _x144 = _type <- Some _x144
    method unset_type = _type <- None
    method reset_type = _type <- None
    val mutable _type_length : Int32.t option = None
    method get_type_length = _type_length

    method grab_type_length =
      match _type_length with
      | None -> raise (Field_empty "schemaElement.type_length")
      | Some _x145 -> _x145

    method set_type_length _x145 = _type_length <- Some _x145
    method unset_type_length = _type_length <- None
    method reset_type_length = _type_length <- None
    val mutable _repetition_type : FieldRepetitionType.t option = None
    method get_repetition_type = _repetition_type

    method grab_repetition_type =
      match _repetition_type with
      | None -> raise (Field_empty "schemaElement.repetition_type")
      | Some _x146 -> _x146

    method set_repetition_type _x146 = _repetition_type <- Some _x146
    method unset_repetition_type = _repetition_type <- None
    method reset_repetition_type = _repetition_type <- None
    val mutable _name : string option = None
    method get_name = _name

    method grab_name =
      match _name with
      | None -> raise (Field_empty "schemaElement.name")
      | Some _x147 -> _x147

    method set_name _x147 = _name <- Some _x147
    method unset_name = _name <- None
    method reset_name = _name <- None
    val mutable _num_children : Int32.t option = None
    method get_num_children = _num_children

    method grab_num_children =
      match _num_children with
      | None -> raise (Field_empty "schemaElement.num_children")
      | Some _x148 -> _x148

    method set_num_children _x148 = _num_children <- Some _x148
    method unset_num_children = _num_children <- None
    method reset_num_children = _num_children <- None
    val mutable _converted_type : ConvertedType.t option = None
    method get_converted_type = _converted_type

    method grab_converted_type =
      match _converted_type with
      | None -> raise (Field_empty "schemaElement.converted_type")
      | Some _x149 -> _x149

    method set_converted_type _x149 = _converted_type <- Some _x149
    method unset_converted_type = _converted_type <- None
    method reset_converted_type = _converted_type <- None
    val mutable _scale : Int32.t option = None
    method get_scale = _scale

    method grab_scale =
      match _scale with
      | None -> raise (Field_empty "schemaElement.scale")
      | Some _x150 -> _x150

    method set_scale _x150 = _scale <- Some _x150
    method unset_scale = _scale <- None
    method reset_scale = _scale <- None
    val mutable _precision : Int32.t option = None
    method get_precision = _precision

    method grab_precision =
      match _precision with
      | None -> raise (Field_empty "schemaElement.precision")
      | Some _x151 -> _x151

    method set_precision _x151 = _precision <- Some _x151
    method unset_precision = _precision <- None
    method reset_precision = _precision <- None
    val mutable _field_id : Int32.t option = None
    method get_field_id = _field_id

    method grab_field_id =
      match _field_id with
      | None -> raise (Field_empty "schemaElement.field_id")
      | Some _x152 -> _x152

    method set_field_id _x152 = _field_id <- Some _x152
    method unset_field_id = _field_id <- None
    method reset_field_id = _field_id <- None
    val mutable _logicalType : logicalType option = None
    method get_logicalType = _logicalType

    method grab_logicalType =
      match _logicalType with
      | None -> raise (Field_empty "schemaElement.logicalType")
      | Some _x153 -> _x153

    method set_logicalType _x153 = _logicalType <- Some _x153
    method unset_logicalType = _logicalType <- None
    method reset_logicalType = _logicalType <- None

    method copy =
      let _new = Oo.copy self in
      if _logicalType <> None then
        _new#set_logicalType self#grab_logicalType#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "SchemaElement";
      (match _type with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("type", Protocol.T_I32, 1);
          oprot#writeI32 (Type.to_i _v);
          oprot#writeFieldEnd);
      (match _type_length with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("type_length", Protocol.T_I32, 2);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _repetition_type with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("repetition_type", Protocol.T_I32, 3);
          oprot#writeI32 (FieldRepetitionType.to_i _v);
          oprot#writeFieldEnd);
      (match _name with
      | None -> raise (Field_empty "schemaElement._name")
      | Some _v ->
          oprot#writeFieldBegin ("name", Protocol.T_STRING, 4);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _num_children with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("num_children", Protocol.T_I32, 5);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _converted_type with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("converted_type", Protocol.T_I32, 6);
          oprot#writeI32 (ConvertedType.to_i _v);
          oprot#writeFieldEnd);
      (match _scale with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("scale", Protocol.T_I32, 7);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _precision with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("precision", Protocol.T_I32, 8);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _field_id with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("field_id", Protocol.T_I32, 9);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _logicalType with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("logicalType", Protocol.T_STRUCT, 10);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_schemaElement (iprot : Protocol.t) =
  let _str156 = new schemaElement in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t157, _id158 = iprot#readFieldBegin in
       if _t157 = Protocol.T_STOP then raise Break else ();
       (match _id158 with
       | 1 ->
           if _t157 = Protocol.T_I32 then
             _str156#set_type (Type.of_i iprot#readI32)
           else iprot#skip _t157
       | 2 ->
           if _t157 = Protocol.T_I32 then _str156#set_type_length iprot#readI32
           else iprot#skip _t157
       | 3 ->
           if _t157 = Protocol.T_I32 then
             _str156#set_repetition_type
               (FieldRepetitionType.of_i iprot#readI32)
           else iprot#skip _t157
       | 4 ->
           if _t157 = Protocol.T_STRING then _str156#set_name iprot#readString
           else iprot#skip _t157
       | 5 ->
           if _t157 = Protocol.T_I32 then _str156#set_num_children iprot#readI32
           else iprot#skip _t157
       | 6 ->
           if _t157 = Protocol.T_I32 then
             _str156#set_converted_type (ConvertedType.of_i iprot#readI32)
           else iprot#skip _t157
       | 7 ->
           if _t157 = Protocol.T_I32 then _str156#set_scale iprot#readI32
           else iprot#skip _t157
       | 8 ->
           if _t157 = Protocol.T_I32 then _str156#set_precision iprot#readI32
           else iprot#skip _t157
       | 9 ->
           if _t157 = Protocol.T_I32 then _str156#set_field_id iprot#readI32
           else iprot#skip _t157
       | 10 ->
           if _t157 = Protocol.T_STRUCT then
             _str156#set_logicalType (read_logicalType iprot)
           else iprot#skip _t157
       | _ -> iprot#skip _t157);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str156

class dataPageHeader =
  object (self)
    val mutable _num_values : Int32.t option = None
    method get_num_values = _num_values

    method grab_num_values =
      match _num_values with
      | None -> raise (Field_empty "dataPageHeader.num_values")
      | Some _x160 -> _x160

    method set_num_values _x160 = _num_values <- Some _x160
    method unset_num_values = _num_values <- None
    method reset_num_values = _num_values <- None
    val mutable _encoding : Encoding.t option = None
    method get_encoding = _encoding

    method grab_encoding =
      match _encoding with
      | None -> raise (Field_empty "dataPageHeader.encoding")
      | Some _x161 -> _x161

    method set_encoding _x161 = _encoding <- Some _x161
    method unset_encoding = _encoding <- None
    method reset_encoding = _encoding <- None
    val mutable _definition_level_encoding : Encoding.t option = None
    method get_definition_level_encoding = _definition_level_encoding

    method grab_definition_level_encoding =
      match _definition_level_encoding with
      | None -> raise (Field_empty "dataPageHeader.definition_level_encoding")
      | Some _x162 -> _x162

    method set_definition_level_encoding _x162 =
      _definition_level_encoding <- Some _x162

    method unset_definition_level_encoding = _definition_level_encoding <- None
    method reset_definition_level_encoding = _definition_level_encoding <- None
    val mutable _repetition_level_encoding : Encoding.t option = None
    method get_repetition_level_encoding = _repetition_level_encoding

    method grab_repetition_level_encoding =
      match _repetition_level_encoding with
      | None -> raise (Field_empty "dataPageHeader.repetition_level_encoding")
      | Some _x163 -> _x163

    method set_repetition_level_encoding _x163 =
      _repetition_level_encoding <- Some _x163

    method unset_repetition_level_encoding = _repetition_level_encoding <- None
    method reset_repetition_level_encoding = _repetition_level_encoding <- None
    val mutable _statistics : statistics option = None
    method get_statistics = _statistics

    method grab_statistics =
      match _statistics with
      | None -> raise (Field_empty "dataPageHeader.statistics")
      | Some _x164 -> _x164

    method set_statistics _x164 = _statistics <- Some _x164
    method unset_statistics = _statistics <- None
    method reset_statistics = _statistics <- None

    method copy =
      let _new = Oo.copy self in
      if _statistics <> None then _new#set_statistics self#grab_statistics#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "DataPageHeader";
      (match _num_values with
      | None -> raise (Field_empty "dataPageHeader._num_values")
      | Some _v ->
          oprot#writeFieldBegin ("num_values", Protocol.T_I32, 1);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _encoding with
      | None -> raise (Field_empty "dataPageHeader._encoding")
      | Some _v ->
          oprot#writeFieldBegin ("encoding", Protocol.T_I32, 2);
          oprot#writeI32 (Encoding.to_i _v);
          oprot#writeFieldEnd);
      (match _definition_level_encoding with
      | None -> raise (Field_empty "dataPageHeader._definition_level_encoding")
      | Some _v ->
          oprot#writeFieldBegin ("definition_level_encoding", Protocol.T_I32, 3);
          oprot#writeI32 (Encoding.to_i _v);
          oprot#writeFieldEnd);
      (match _repetition_level_encoding with
      | None -> raise (Field_empty "dataPageHeader._repetition_level_encoding")
      | Some _v ->
          oprot#writeFieldBegin ("repetition_level_encoding", Protocol.T_I32, 4);
          oprot#writeI32 (Encoding.to_i _v);
          oprot#writeFieldEnd);
      (match _statistics with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("statistics", Protocol.T_STRUCT, 5);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_dataPageHeader (iprot : Protocol.t) =
  let _str167 = new dataPageHeader in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t168, _id169 = iprot#readFieldBegin in
       if _t168 = Protocol.T_STOP then raise Break else ();
       (match _id169 with
       | 1 ->
           if _t168 = Protocol.T_I32 then _str167#set_num_values iprot#readI32
           else iprot#skip _t168
       | 2 ->
           if _t168 = Protocol.T_I32 then
             _str167#set_encoding (Encoding.of_i iprot#readI32)
           else iprot#skip _t168
       | 3 ->
           if _t168 = Protocol.T_I32 then
             _str167#set_definition_level_encoding (Encoding.of_i iprot#readI32)
           else iprot#skip _t168
       | 4 ->
           if _t168 = Protocol.T_I32 then
             _str167#set_repetition_level_encoding (Encoding.of_i iprot#readI32)
           else iprot#skip _t168
       | 5 ->
           if _t168 = Protocol.T_STRUCT then
             _str167#set_statistics (read_statistics iprot)
           else iprot#skip _t168
       | _ -> iprot#skip _t168);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str167

class indexPageHeader =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "IndexPageHeader";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_indexPageHeader (iprot : Protocol.t) =
  let _str173 = new indexPageHeader in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t174, _id175 = iprot#readFieldBegin in
       if _t174 = Protocol.T_STOP then raise Break else ();
       (match _id175 with _ -> iprot#skip _t174);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str173

class dictionaryPageHeader =
  object (self)
    val mutable _num_values : Int32.t option = None
    method get_num_values = _num_values

    method grab_num_values =
      match _num_values with
      | None -> raise (Field_empty "dictionaryPageHeader.num_values")
      | Some _x177 -> _x177

    method set_num_values _x177 = _num_values <- Some _x177
    method unset_num_values = _num_values <- None
    method reset_num_values = _num_values <- None
    val mutable _encoding : Encoding.t option = None
    method get_encoding = _encoding

    method grab_encoding =
      match _encoding with
      | None -> raise (Field_empty "dictionaryPageHeader.encoding")
      | Some _x178 -> _x178

    method set_encoding _x178 = _encoding <- Some _x178
    method unset_encoding = _encoding <- None
    method reset_encoding = _encoding <- None
    val mutable _is_sorted : bool option = None
    method get_is_sorted = _is_sorted

    method grab_is_sorted =
      match _is_sorted with
      | None -> raise (Field_empty "dictionaryPageHeader.is_sorted")
      | Some _x179 -> _x179

    method set_is_sorted _x179 = _is_sorted <- Some _x179
    method unset_is_sorted = _is_sorted <- None
    method reset_is_sorted = _is_sorted <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "DictionaryPageHeader";
      (match _num_values with
      | None -> raise (Field_empty "dictionaryPageHeader._num_values")
      | Some _v ->
          oprot#writeFieldBegin ("num_values", Protocol.T_I32, 1);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _encoding with
      | None -> raise (Field_empty "dictionaryPageHeader._encoding")
      | Some _v ->
          oprot#writeFieldBegin ("encoding", Protocol.T_I32, 2);
          oprot#writeI32 (Encoding.to_i _v);
          oprot#writeFieldEnd);
      (match _is_sorted with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("is_sorted", Protocol.T_BOOL, 3);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_dictionaryPageHeader (iprot : Protocol.t) =
  let _str182 = new dictionaryPageHeader in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t183, _id184 = iprot#readFieldBegin in
       if _t183 = Protocol.T_STOP then raise Break else ();
       (match _id184 with
       | 1 ->
           if _t183 = Protocol.T_I32 then _str182#set_num_values iprot#readI32
           else iprot#skip _t183
       | 2 ->
           if _t183 = Protocol.T_I32 then
             _str182#set_encoding (Encoding.of_i iprot#readI32)
           else iprot#skip _t183
       | 3 ->
           if _t183 = Protocol.T_BOOL then _str182#set_is_sorted iprot#readBool
           else iprot#skip _t183
       | _ -> iprot#skip _t183);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str182

class dataPageHeaderV2 =
  object (self)
    val mutable _num_values : Int32.t option = None
    method get_num_values = _num_values

    method grab_num_values =
      match _num_values with
      | None -> raise (Field_empty "dataPageHeaderV2.num_values")
      | Some _x186 -> _x186

    method set_num_values _x186 = _num_values <- Some _x186
    method unset_num_values = _num_values <- None
    method reset_num_values = _num_values <- None
    val mutable _num_nulls : Int32.t option = None
    method get_num_nulls = _num_nulls

    method grab_num_nulls =
      match _num_nulls with
      | None -> raise (Field_empty "dataPageHeaderV2.num_nulls")
      | Some _x187 -> _x187

    method set_num_nulls _x187 = _num_nulls <- Some _x187
    method unset_num_nulls = _num_nulls <- None
    method reset_num_nulls = _num_nulls <- None
    val mutable _num_rows : Int32.t option = None
    method get_num_rows = _num_rows

    method grab_num_rows =
      match _num_rows with
      | None -> raise (Field_empty "dataPageHeaderV2.num_rows")
      | Some _x188 -> _x188

    method set_num_rows _x188 = _num_rows <- Some _x188
    method unset_num_rows = _num_rows <- None
    method reset_num_rows = _num_rows <- None
    val mutable _encoding : Encoding.t option = None
    method get_encoding = _encoding

    method grab_encoding =
      match _encoding with
      | None -> raise (Field_empty "dataPageHeaderV2.encoding")
      | Some _x189 -> _x189

    method set_encoding _x189 = _encoding <- Some _x189
    method unset_encoding = _encoding <- None
    method reset_encoding = _encoding <- None
    val mutable _definition_levels_byte_length : Int32.t option = None
    method get_definition_levels_byte_length = _definition_levels_byte_length

    method grab_definition_levels_byte_length =
      match _definition_levels_byte_length with
      | None ->
          raise (Field_empty "dataPageHeaderV2.definition_levels_byte_length")
      | Some _x190 -> _x190

    method set_definition_levels_byte_length _x190 =
      _definition_levels_byte_length <- Some _x190

    method unset_definition_levels_byte_length =
      _definition_levels_byte_length <- None

    method reset_definition_levels_byte_length =
      _definition_levels_byte_length <- None

    val mutable _repetition_levels_byte_length : Int32.t option = None
    method get_repetition_levels_byte_length = _repetition_levels_byte_length

    method grab_repetition_levels_byte_length =
      match _repetition_levels_byte_length with
      | None ->
          raise (Field_empty "dataPageHeaderV2.repetition_levels_byte_length")
      | Some _x191 -> _x191

    method set_repetition_levels_byte_length _x191 =
      _repetition_levels_byte_length <- Some _x191

    method unset_repetition_levels_byte_length =
      _repetition_levels_byte_length <- None

    method reset_repetition_levels_byte_length =
      _repetition_levels_byte_length <- None

    val mutable _is_compressed : bool = true
    method get_is_compressed = Some _is_compressed
    method grab_is_compressed = _is_compressed
    method set_is_compressed _x192 = _is_compressed <- _x192
    method reset_is_compressed = _is_compressed <- true
    val mutable _statistics : statistics option = None
    method get_statistics = _statistics

    method grab_statistics =
      match _statistics with
      | None -> raise (Field_empty "dataPageHeaderV2.statistics")
      | Some _x193 -> _x193

    method set_statistics _x193 = _statistics <- Some _x193
    method unset_statistics = _statistics <- None
    method reset_statistics = _statistics <- None

    method copy =
      let _new = Oo.copy self in
      if _statistics <> None then _new#set_statistics self#grab_statistics#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "DataPageHeaderV2";
      (match _num_values with
      | None -> raise (Field_empty "dataPageHeaderV2._num_values")
      | Some _v ->
          oprot#writeFieldBegin ("num_values", Protocol.T_I32, 1);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _num_nulls with
      | None -> raise (Field_empty "dataPageHeaderV2._num_nulls")
      | Some _v ->
          oprot#writeFieldBegin ("num_nulls", Protocol.T_I32, 2);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _num_rows with
      | None -> raise (Field_empty "dataPageHeaderV2._num_rows")
      | Some _v ->
          oprot#writeFieldBegin ("num_rows", Protocol.T_I32, 3);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _encoding with
      | None -> raise (Field_empty "dataPageHeaderV2._encoding")
      | Some _v ->
          oprot#writeFieldBegin ("encoding", Protocol.T_I32, 4);
          oprot#writeI32 (Encoding.to_i _v);
          oprot#writeFieldEnd);
      (match _definition_levels_byte_length with
      | None ->
          raise (Field_empty "dataPageHeaderV2._definition_levels_byte_length")
      | Some _v ->
          oprot#writeFieldBegin
            ("definition_levels_byte_length", Protocol.T_I32, 5);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _repetition_levels_byte_length with
      | None ->
          raise (Field_empty "dataPageHeaderV2._repetition_levels_byte_length")
      | Some _v ->
          oprot#writeFieldBegin
            ("repetition_levels_byte_length", Protocol.T_I32, 6);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _is_compressed with
      | true -> ()
      | _v ->
          oprot#writeFieldBegin ("is_compressed", Protocol.T_BOOL, 7);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      (match _statistics with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("statistics", Protocol.T_STRUCT, 8);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_dataPageHeaderV2 (iprot : Protocol.t) =
  let _str196 = new dataPageHeaderV2 in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t197, _id198 = iprot#readFieldBegin in
       if _t197 = Protocol.T_STOP then raise Break else ();
       (match _id198 with
       | 1 ->
           if _t197 = Protocol.T_I32 then _str196#set_num_values iprot#readI32
           else iprot#skip _t197
       | 2 ->
           if _t197 = Protocol.T_I32 then _str196#set_num_nulls iprot#readI32
           else iprot#skip _t197
       | 3 ->
           if _t197 = Protocol.T_I32 then _str196#set_num_rows iprot#readI32
           else iprot#skip _t197
       | 4 ->
           if _t197 = Protocol.T_I32 then
             _str196#set_encoding (Encoding.of_i iprot#readI32)
           else iprot#skip _t197
       | 5 ->
           if _t197 = Protocol.T_I32 then
             _str196#set_definition_levels_byte_length iprot#readI32
           else iprot#skip _t197
       | 6 ->
           if _t197 = Protocol.T_I32 then
             _str196#set_repetition_levels_byte_length iprot#readI32
           else iprot#skip _t197
       | 7 ->
           if _t197 = Protocol.T_BOOL then
             _str196#set_is_compressed iprot#readBool
           else iprot#skip _t197
       | 8 ->
           if _t197 = Protocol.T_STRUCT then
             _str196#set_statistics (read_statistics iprot)
           else iprot#skip _t197
       | _ -> iprot#skip _t197);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str196

class splitBlockAlgorithm =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "SplitBlockAlgorithm";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_splitBlockAlgorithm (iprot : Protocol.t) =
  let _str202 = new splitBlockAlgorithm in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t203, _id204 = iprot#readFieldBegin in
       if _t203 = Protocol.T_STOP then raise Break else ();
       (match _id204 with _ -> iprot#skip _t203);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str202

class bloomFilterAlgorithm =
  object (self)
    val mutable _bLOCK : splitBlockAlgorithm option = None
    method get_bLOCK = _bLOCK

    method grab_bLOCK =
      match _bLOCK with
      | None -> raise (Field_empty "bloomFilterAlgorithm.bLOCK")
      | Some _x206 -> _x206

    method set_bLOCK _x206 = _bLOCK <- Some _x206
    method unset_bLOCK = _bLOCK <- None
    method reset_bLOCK = _bLOCK <- None

    method copy =
      let _new = Oo.copy self in
      if _bLOCK <> None then _new#set_bLOCK self#grab_bLOCK#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "BloomFilterAlgorithm";
      (match _bLOCK with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("BLOCK", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_bloomFilterAlgorithm (iprot : Protocol.t) =
  let _str209 = new bloomFilterAlgorithm in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t210, _id211 = iprot#readFieldBegin in
       if _t210 = Protocol.T_STOP then raise Break else ();
       (match _id211 with
       | 1 ->
           if _t210 = Protocol.T_STRUCT then
             _str209#set_bLOCK (read_splitBlockAlgorithm iprot)
           else iprot#skip _t210
       | _ -> iprot#skip _t210);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str209

class xxHash =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "XxHash";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_xxHash (iprot : Protocol.t) =
  let _str215 = new xxHash in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t216, _id217 = iprot#readFieldBegin in
       if _t216 = Protocol.T_STOP then raise Break else ();
       (match _id217 with _ -> iprot#skip _t216);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str215

class bloomFilterHash =
  object (self)
    val mutable _xXHASH : xxHash option = None
    method get_xXHASH = _xXHASH

    method grab_xXHASH =
      match _xXHASH with
      | None -> raise (Field_empty "bloomFilterHash.xXHASH")
      | Some _x219 -> _x219

    method set_xXHASH _x219 = _xXHASH <- Some _x219
    method unset_xXHASH = _xXHASH <- None
    method reset_xXHASH = _xXHASH <- None

    method copy =
      let _new = Oo.copy self in
      if _xXHASH <> None then _new#set_xXHASH self#grab_xXHASH#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "BloomFilterHash";
      (match _xXHASH with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("XXHASH", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_bloomFilterHash (iprot : Protocol.t) =
  let _str222 = new bloomFilterHash in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t223, _id224 = iprot#readFieldBegin in
       if _t223 = Protocol.T_STOP then raise Break else ();
       (match _id224 with
       | 1 ->
           if _t223 = Protocol.T_STRUCT then
             _str222#set_xXHASH (read_xxHash iprot)
           else iprot#skip _t223
       | _ -> iprot#skip _t223);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str222

class uncompressed =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "Uncompressed";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_uncompressed (iprot : Protocol.t) =
  let _str228 = new uncompressed in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t229, _id230 = iprot#readFieldBegin in
       if _t229 = Protocol.T_STOP then raise Break else ();
       (match _id230 with _ -> iprot#skip _t229);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str228

class bloomFilterCompression =
  object (self)
    val mutable _uNCOMPRESSED : uncompressed option = None
    method get_uNCOMPRESSED = _uNCOMPRESSED

    method grab_uNCOMPRESSED =
      match _uNCOMPRESSED with
      | None -> raise (Field_empty "bloomFilterCompression.uNCOMPRESSED")
      | Some _x232 -> _x232

    method set_uNCOMPRESSED _x232 = _uNCOMPRESSED <- Some _x232
    method unset_uNCOMPRESSED = _uNCOMPRESSED <- None
    method reset_uNCOMPRESSED = _uNCOMPRESSED <- None

    method copy =
      let _new = Oo.copy self in
      if _uNCOMPRESSED <> None then
        _new#set_uNCOMPRESSED self#grab_uNCOMPRESSED#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "BloomFilterCompression";
      (match _uNCOMPRESSED with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("UNCOMPRESSED", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_bloomFilterCompression (iprot : Protocol.t) =
  let _str235 = new bloomFilterCompression in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t236, _id237 = iprot#readFieldBegin in
       if _t236 = Protocol.T_STOP then raise Break else ();
       (match _id237 with
       | 1 ->
           if _t236 = Protocol.T_STRUCT then
             _str235#set_uNCOMPRESSED (read_uncompressed iprot)
           else iprot#skip _t236
       | _ -> iprot#skip _t236);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str235

class bloomFilterHeader =
  object (self)
    val mutable _numBytes : Int32.t option = None
    method get_numBytes = _numBytes

    method grab_numBytes =
      match _numBytes with
      | None -> raise (Field_empty "bloomFilterHeader.numBytes")
      | Some _x239 -> _x239

    method set_numBytes _x239 = _numBytes <- Some _x239
    method unset_numBytes = _numBytes <- None
    method reset_numBytes = _numBytes <- None
    val mutable _algorithm : bloomFilterAlgorithm option = None
    method get_algorithm = _algorithm

    method grab_algorithm =
      match _algorithm with
      | None -> raise (Field_empty "bloomFilterHeader.algorithm")
      | Some _x240 -> _x240

    method set_algorithm _x240 = _algorithm <- Some _x240
    method unset_algorithm = _algorithm <- None
    method reset_algorithm = _algorithm <- None
    val mutable _hash : bloomFilterHash option = None
    method get_hash = _hash

    method grab_hash =
      match _hash with
      | None -> raise (Field_empty "bloomFilterHeader.hash")
      | Some _x241 -> _x241

    method set_hash _x241 = _hash <- Some _x241
    method unset_hash = _hash <- None
    method reset_hash = _hash <- None
    val mutable _compression : bloomFilterCompression option = None
    method get_compression = _compression

    method grab_compression =
      match _compression with
      | None -> raise (Field_empty "bloomFilterHeader.compression")
      | Some _x242 -> _x242

    method set_compression _x242 = _compression <- Some _x242
    method unset_compression = _compression <- None
    method reset_compression = _compression <- None

    method copy =
      let _new = Oo.copy self in
      if _algorithm <> None then _new#set_algorithm self#grab_algorithm#copy;
      if _hash <> None then _new#set_hash self#grab_hash#copy;
      if _compression <> None then
        _new#set_compression self#grab_compression#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "BloomFilterHeader";
      (match _numBytes with
      | None -> raise (Field_empty "bloomFilterHeader._numBytes")
      | Some _v ->
          oprot#writeFieldBegin ("numBytes", Protocol.T_I32, 1);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _algorithm with
      | None -> raise (Field_empty "bloomFilterHeader._algorithm")
      | Some _v ->
          oprot#writeFieldBegin ("algorithm", Protocol.T_STRUCT, 2);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _hash with
      | None -> raise (Field_empty "bloomFilterHeader._hash")
      | Some _v ->
          oprot#writeFieldBegin ("hash", Protocol.T_STRUCT, 3);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _compression with
      | None -> raise (Field_empty "bloomFilterHeader._compression")
      | Some _v ->
          oprot#writeFieldBegin ("compression", Protocol.T_STRUCT, 4);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_bloomFilterHeader (iprot : Protocol.t) =
  let _str245 = new bloomFilterHeader in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t246, _id247 = iprot#readFieldBegin in
       if _t246 = Protocol.T_STOP then raise Break else ();
       (match _id247 with
       | 1 ->
           if _t246 = Protocol.T_I32 then _str245#set_numBytes iprot#readI32
           else iprot#skip _t246
       | 2 ->
           if _t246 = Protocol.T_STRUCT then
             _str245#set_algorithm (read_bloomFilterAlgorithm iprot)
           else iprot#skip _t246
       | 3 ->
           if _t246 = Protocol.T_STRUCT then
             _str245#set_hash (read_bloomFilterHash iprot)
           else iprot#skip _t246
       | 4 ->
           if _t246 = Protocol.T_STRUCT then
             _str245#set_compression (read_bloomFilterCompression iprot)
           else iprot#skip _t246
       | _ -> iprot#skip _t246);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str245

class pageHeader =
  object (self)
    val mutable _type : PageType.t option = None
    method get_type = _type

    method grab_type =
      match _type with
      | None -> raise (Field_empty "pageHeader.type")
      | Some _x249 -> _x249

    method set_type _x249 = _type <- Some _x249
    method unset_type = _type <- None
    method reset_type = _type <- None
    val mutable _uncompressed_page_size : Int32.t option = None
    method get_uncompressed_page_size = _uncompressed_page_size

    method grab_uncompressed_page_size =
      match _uncompressed_page_size with
      | None -> raise (Field_empty "pageHeader.uncompressed_page_size")
      | Some _x250 -> _x250

    method set_uncompressed_page_size _x250 =
      _uncompressed_page_size <- Some _x250

    method unset_uncompressed_page_size = _uncompressed_page_size <- None
    method reset_uncompressed_page_size = _uncompressed_page_size <- None
    val mutable _compressed_page_size : Int32.t option = None
    method get_compressed_page_size = _compressed_page_size

    method grab_compressed_page_size =
      match _compressed_page_size with
      | None -> raise (Field_empty "pageHeader.compressed_page_size")
      | Some _x251 -> _x251

    method set_compressed_page_size _x251 = _compressed_page_size <- Some _x251
    method unset_compressed_page_size = _compressed_page_size <- None
    method reset_compressed_page_size = _compressed_page_size <- None
    val mutable _crc : Int32.t option = None
    method get_crc = _crc

    method grab_crc =
      match _crc with
      | None -> raise (Field_empty "pageHeader.crc")
      | Some _x252 -> _x252

    method set_crc _x252 = _crc <- Some _x252
    method unset_crc = _crc <- None
    method reset_crc = _crc <- None
    val mutable _data_page_header : dataPageHeader option = None
    method get_data_page_header = _data_page_header

    method grab_data_page_header =
      match _data_page_header with
      | None -> raise (Field_empty "pageHeader.data_page_header")
      | Some _x253 -> _x253

    method set_data_page_header _x253 = _data_page_header <- Some _x253
    method unset_data_page_header = _data_page_header <- None
    method reset_data_page_header = _data_page_header <- None
    val mutable _index_page_header : indexPageHeader option = None
    method get_index_page_header = _index_page_header

    method grab_index_page_header =
      match _index_page_header with
      | None -> raise (Field_empty "pageHeader.index_page_header")
      | Some _x254 -> _x254

    method set_index_page_header _x254 = _index_page_header <- Some _x254
    method unset_index_page_header = _index_page_header <- None
    method reset_index_page_header = _index_page_header <- None
    val mutable _dictionary_page_header : dictionaryPageHeader option = None
    method get_dictionary_page_header = _dictionary_page_header

    method grab_dictionary_page_header =
      match _dictionary_page_header with
      | None -> raise (Field_empty "pageHeader.dictionary_page_header")
      | Some _x255 -> _x255

    method set_dictionary_page_header _x255 =
      _dictionary_page_header <- Some _x255

    method unset_dictionary_page_header = _dictionary_page_header <- None
    method reset_dictionary_page_header = _dictionary_page_header <- None
    val mutable _data_page_header_v2 : dataPageHeaderV2 option = None
    method get_data_page_header_v2 = _data_page_header_v2

    method grab_data_page_header_v2 =
      match _data_page_header_v2 with
      | None -> raise (Field_empty "pageHeader.data_page_header_v2")
      | Some _x256 -> _x256

    method set_data_page_header_v2 _x256 = _data_page_header_v2 <- Some _x256
    method unset_data_page_header_v2 = _data_page_header_v2 <- None
    method reset_data_page_header_v2 = _data_page_header_v2 <- None

    method copy =
      let _new = Oo.copy self in
      if _data_page_header <> None then
        _new#set_data_page_header self#grab_data_page_header#copy;
      if _index_page_header <> None then
        _new#set_index_page_header self#grab_index_page_header#copy;
      if _dictionary_page_header <> None then
        _new#set_dictionary_page_header self#grab_dictionary_page_header#copy;
      if _data_page_header_v2 <> None then
        _new#set_data_page_header_v2 self#grab_data_page_header_v2#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "PageHeader";
      (match _type with
      | None -> raise (Field_empty "pageHeader._type")
      | Some _v ->
          oprot#writeFieldBegin ("type", Protocol.T_I32, 1);
          oprot#writeI32 (PageType.to_i _v);
          oprot#writeFieldEnd);
      (match _uncompressed_page_size with
      | None -> raise (Field_empty "pageHeader._uncompressed_page_size")
      | Some _v ->
          oprot#writeFieldBegin ("uncompressed_page_size", Protocol.T_I32, 2);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _compressed_page_size with
      | None -> raise (Field_empty "pageHeader._compressed_page_size")
      | Some _v ->
          oprot#writeFieldBegin ("compressed_page_size", Protocol.T_I32, 3);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _crc with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("crc", Protocol.T_I32, 4);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _data_page_header with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("data_page_header", Protocol.T_STRUCT, 5);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _index_page_header with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("index_page_header", Protocol.T_STRUCT, 6);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _dictionary_page_header with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("dictionary_page_header", Protocol.T_STRUCT, 7);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _data_page_header_v2 with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("data_page_header_v2", Protocol.T_STRUCT, 8);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_pageHeader (iprot : Protocol.t) =
  let _str259 = new pageHeader in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t260, _id261 = iprot#readFieldBegin in
       if _t260 = Protocol.T_STOP then raise Break else ();
       (match _id261 with
       | 1 ->
           if _t260 = Protocol.T_I32 then
             _str259#set_type (PageType.of_i iprot#readI32)
           else iprot#skip _t260
       | 2 ->
           if _t260 = Protocol.T_I32 then
             _str259#set_uncompressed_page_size iprot#readI32
           else iprot#skip _t260
       | 3 ->
           if _t260 = Protocol.T_I32 then
             _str259#set_compressed_page_size iprot#readI32
           else iprot#skip _t260
       | 4 ->
           if _t260 = Protocol.T_I32 then _str259#set_crc iprot#readI32
           else iprot#skip _t260
       | 5 ->
           if _t260 = Protocol.T_STRUCT then
             _str259#set_data_page_header (read_dataPageHeader iprot)
           else iprot#skip _t260
       | 6 ->
           if _t260 = Protocol.T_STRUCT then
             _str259#set_index_page_header (read_indexPageHeader iprot)
           else iprot#skip _t260
       | 7 ->
           if _t260 = Protocol.T_STRUCT then
             _str259#set_dictionary_page_header
               (read_dictionaryPageHeader iprot)
           else iprot#skip _t260
       | 8 ->
           if _t260 = Protocol.T_STRUCT then
             _str259#set_data_page_header_v2 (read_dataPageHeaderV2 iprot)
           else iprot#skip _t260
       | _ -> iprot#skip _t260);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str259

class keyValue =
  object (self)
    val mutable _key : string option = None
    method get_key = _key

    method grab_key =
      match _key with
      | None -> raise (Field_empty "keyValue.key")
      | Some _x263 -> _x263

    method set_key _x263 = _key <- Some _x263
    method unset_key = _key <- None
    method reset_key = _key <- None
    val mutable _value : string option = None
    method get_value = _value

    method grab_value =
      match _value with
      | None -> raise (Field_empty "keyValue.value")
      | Some _x264 -> _x264

    method set_value _x264 = _value <- Some _x264
    method unset_value = _value <- None
    method reset_value = _value <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "KeyValue";
      (match _key with
      | None -> raise (Field_empty "keyValue._key")
      | Some _v ->
          oprot#writeFieldBegin ("key", Protocol.T_STRING, 1);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _value with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("value", Protocol.T_STRING, 2);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_keyValue (iprot : Protocol.t) =
  let _str267 = new keyValue in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t268, _id269 = iprot#readFieldBegin in
       if _t268 = Protocol.T_STOP then raise Break else ();
       (match _id269 with
       | 1 ->
           if _t268 = Protocol.T_STRING then _str267#set_key iprot#readString
           else iprot#skip _t268
       | 2 ->
           if _t268 = Protocol.T_STRING then _str267#set_value iprot#readString
           else iprot#skip _t268
       | _ -> iprot#skip _t268);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str267

class sortingColumn =
  object (self)
    val mutable _column_idx : Int32.t option = None
    method get_column_idx = _column_idx

    method grab_column_idx =
      match _column_idx with
      | None -> raise (Field_empty "sortingColumn.column_idx")
      | Some _x271 -> _x271

    method set_column_idx _x271 = _column_idx <- Some _x271
    method unset_column_idx = _column_idx <- None
    method reset_column_idx = _column_idx <- None
    val mutable _descending : bool option = None
    method get_descending = _descending

    method grab_descending =
      match _descending with
      | None -> raise (Field_empty "sortingColumn.descending")
      | Some _x272 -> _x272

    method set_descending _x272 = _descending <- Some _x272
    method unset_descending = _descending <- None
    method reset_descending = _descending <- None
    val mutable _nulls_first : bool option = None
    method get_nulls_first = _nulls_first

    method grab_nulls_first =
      match _nulls_first with
      | None -> raise (Field_empty "sortingColumn.nulls_first")
      | Some _x273 -> _x273

    method set_nulls_first _x273 = _nulls_first <- Some _x273
    method unset_nulls_first = _nulls_first <- None
    method reset_nulls_first = _nulls_first <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "SortingColumn";
      (match _column_idx with
      | None -> raise (Field_empty "sortingColumn._column_idx")
      | Some _v ->
          oprot#writeFieldBegin ("column_idx", Protocol.T_I32, 1);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _descending with
      | None -> raise (Field_empty "sortingColumn._descending")
      | Some _v ->
          oprot#writeFieldBegin ("descending", Protocol.T_BOOL, 2);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      (match _nulls_first with
      | None -> raise (Field_empty "sortingColumn._nulls_first")
      | Some _v ->
          oprot#writeFieldBegin ("nulls_first", Protocol.T_BOOL, 3);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_sortingColumn (iprot : Protocol.t) =
  let _str276 = new sortingColumn in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t277, _id278 = iprot#readFieldBegin in
       if _t277 = Protocol.T_STOP then raise Break else ();
       (match _id278 with
       | 1 ->
           if _t277 = Protocol.T_I32 then _str276#set_column_idx iprot#readI32
           else iprot#skip _t277
       | 2 ->
           if _t277 = Protocol.T_BOOL then _str276#set_descending iprot#readBool
           else iprot#skip _t277
       | 3 ->
           if _t277 = Protocol.T_BOOL then
             _str276#set_nulls_first iprot#readBool
           else iprot#skip _t277
       | _ -> iprot#skip _t277);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str276

class pageEncodingStats =
  object (self)
    val mutable _page_type : PageType.t option = None
    method get_page_type = _page_type

    method grab_page_type =
      match _page_type with
      | None -> raise (Field_empty "pageEncodingStats.page_type")
      | Some _x280 -> _x280

    method set_page_type _x280 = _page_type <- Some _x280
    method unset_page_type = _page_type <- None
    method reset_page_type = _page_type <- None
    val mutable _encoding : Encoding.t option = None
    method get_encoding = _encoding

    method grab_encoding =
      match _encoding with
      | None -> raise (Field_empty "pageEncodingStats.encoding")
      | Some _x281 -> _x281

    method set_encoding _x281 = _encoding <- Some _x281
    method unset_encoding = _encoding <- None
    method reset_encoding = _encoding <- None
    val mutable _count : Int32.t option = None
    method get_count = _count

    method grab_count =
      match _count with
      | None -> raise (Field_empty "pageEncodingStats.count")
      | Some _x282 -> _x282

    method set_count _x282 = _count <- Some _x282
    method unset_count = _count <- None
    method reset_count = _count <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "PageEncodingStats";
      (match _page_type with
      | None -> raise (Field_empty "pageEncodingStats._page_type")
      | Some _v ->
          oprot#writeFieldBegin ("page_type", Protocol.T_I32, 1);
          oprot#writeI32 (PageType.to_i _v);
          oprot#writeFieldEnd);
      (match _encoding with
      | None -> raise (Field_empty "pageEncodingStats._encoding")
      | Some _v ->
          oprot#writeFieldBegin ("encoding", Protocol.T_I32, 2);
          oprot#writeI32 (Encoding.to_i _v);
          oprot#writeFieldEnd);
      (match _count with
      | None -> raise (Field_empty "pageEncodingStats._count")
      | Some _v ->
          oprot#writeFieldBegin ("count", Protocol.T_I32, 3);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_pageEncodingStats (iprot : Protocol.t) =
  let _str285 = new pageEncodingStats in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t286, _id287 = iprot#readFieldBegin in
       if _t286 = Protocol.T_STOP then raise Break else ();
       (match _id287 with
       | 1 ->
           if _t286 = Protocol.T_I32 then
             _str285#set_page_type (PageType.of_i iprot#readI32)
           else iprot#skip _t286
       | 2 ->
           if _t286 = Protocol.T_I32 then
             _str285#set_encoding (Encoding.of_i iprot#readI32)
           else iprot#skip _t286
       | 3 ->
           if _t286 = Protocol.T_I32 then _str285#set_count iprot#readI32
           else iprot#skip _t286
       | _ -> iprot#skip _t286);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str285

class columnMetaData =
  object (self)
    val mutable _type : Type.t option = None
    method get_type = _type

    method grab_type =
      match _type with
      | None -> raise (Field_empty "columnMetaData.type")
      | Some _x289 -> _x289

    method set_type _x289 = _type <- Some _x289
    method unset_type = _type <- None
    method reset_type = _type <- None
    val mutable _encodings : Encoding.t list option = None
    method get_encodings = _encodings

    method grab_encodings =
      match _encodings with
      | None -> raise (Field_empty "columnMetaData.encodings")
      | Some _x290 -> _x290

    method set_encodings _x290 = _encodings <- Some _x290
    method unset_encodings = _encodings <- None
    method reset_encodings = _encodings <- None
    val mutable _path_in_schema : string list option = None
    method get_path_in_schema = _path_in_schema

    method grab_path_in_schema =
      match _path_in_schema with
      | None -> raise (Field_empty "columnMetaData.path_in_schema")
      | Some _x291 -> _x291

    method set_path_in_schema _x291 = _path_in_schema <- Some _x291
    method unset_path_in_schema = _path_in_schema <- None
    method reset_path_in_schema = _path_in_schema <- None
    val mutable _codec : CompressionCodec.t option = None
    method get_codec = _codec

    method grab_codec =
      match _codec with
      | None -> raise (Field_empty "columnMetaData.codec")
      | Some _x292 -> _x292

    method set_codec _x292 = _codec <- Some _x292
    method unset_codec = _codec <- None
    method reset_codec = _codec <- None
    val mutable _num_values : Int64.t option = None
    method get_num_values = _num_values

    method grab_num_values =
      match _num_values with
      | None -> raise (Field_empty "columnMetaData.num_values")
      | Some _x293 -> _x293

    method set_num_values _x293 = _num_values <- Some _x293
    method unset_num_values = _num_values <- None
    method reset_num_values = _num_values <- None
    val mutable _total_uncompressed_size : Int64.t option = None
    method get_total_uncompressed_size = _total_uncompressed_size

    method grab_total_uncompressed_size =
      match _total_uncompressed_size with
      | None -> raise (Field_empty "columnMetaData.total_uncompressed_size")
      | Some _x294 -> _x294

    method set_total_uncompressed_size _x294 =
      _total_uncompressed_size <- Some _x294

    method unset_total_uncompressed_size = _total_uncompressed_size <- None
    method reset_total_uncompressed_size = _total_uncompressed_size <- None
    val mutable _total_compressed_size : Int64.t option = None
    method get_total_compressed_size = _total_compressed_size

    method grab_total_compressed_size =
      match _total_compressed_size with
      | None -> raise (Field_empty "columnMetaData.total_compressed_size")
      | Some _x295 -> _x295

    method set_total_compressed_size _x295 =
      _total_compressed_size <- Some _x295

    method unset_total_compressed_size = _total_compressed_size <- None
    method reset_total_compressed_size = _total_compressed_size <- None
    val mutable _key_value_metadata : keyValue list option = None
    method get_key_value_metadata = _key_value_metadata

    method grab_key_value_metadata =
      match _key_value_metadata with
      | None -> raise (Field_empty "columnMetaData.key_value_metadata")
      | Some _x296 -> _x296

    method set_key_value_metadata _x296 = _key_value_metadata <- Some _x296
    method unset_key_value_metadata = _key_value_metadata <- None
    method reset_key_value_metadata = _key_value_metadata <- None
    val mutable _data_page_offset : Int64.t option = None
    method get_data_page_offset = _data_page_offset

    method grab_data_page_offset =
      match _data_page_offset with
      | None -> raise (Field_empty "columnMetaData.data_page_offset")
      | Some _x297 -> _x297

    method set_data_page_offset _x297 = _data_page_offset <- Some _x297
    method unset_data_page_offset = _data_page_offset <- None
    method reset_data_page_offset = _data_page_offset <- None
    val mutable _index_page_offset : Int64.t option = None
    method get_index_page_offset = _index_page_offset

    method grab_index_page_offset =
      match _index_page_offset with
      | None -> raise (Field_empty "columnMetaData.index_page_offset")
      | Some _x298 -> _x298

    method set_index_page_offset _x298 = _index_page_offset <- Some _x298
    method unset_index_page_offset = _index_page_offset <- None
    method reset_index_page_offset = _index_page_offset <- None
    val mutable _dictionary_page_offset : Int64.t option = None
    method get_dictionary_page_offset = _dictionary_page_offset

    method grab_dictionary_page_offset =
      match _dictionary_page_offset with
      | None -> raise (Field_empty "columnMetaData.dictionary_page_offset")
      | Some _x299 -> _x299

    method set_dictionary_page_offset _x299 =
      _dictionary_page_offset <- Some _x299

    method unset_dictionary_page_offset = _dictionary_page_offset <- None
    method reset_dictionary_page_offset = _dictionary_page_offset <- None
    val mutable _statistics : statistics option = None
    method get_statistics = _statistics

    method grab_statistics =
      match _statistics with
      | None -> raise (Field_empty "columnMetaData.statistics")
      | Some _x300 -> _x300

    method set_statistics _x300 = _statistics <- Some _x300
    method unset_statistics = _statistics <- None
    method reset_statistics = _statistics <- None
    val mutable _encoding_stats : pageEncodingStats list option = None
    method get_encoding_stats = _encoding_stats

    method grab_encoding_stats =
      match _encoding_stats with
      | None -> raise (Field_empty "columnMetaData.encoding_stats")
      | Some _x301 -> _x301

    method set_encoding_stats _x301 = _encoding_stats <- Some _x301
    method unset_encoding_stats = _encoding_stats <- None
    method reset_encoding_stats = _encoding_stats <- None
    val mutable _bloom_filter_offset : Int64.t option = None
    method get_bloom_filter_offset = _bloom_filter_offset

    method grab_bloom_filter_offset =
      match _bloom_filter_offset with
      | None -> raise (Field_empty "columnMetaData.bloom_filter_offset")
      | Some _x302 -> _x302

    method set_bloom_filter_offset _x302 = _bloom_filter_offset <- Some _x302
    method unset_bloom_filter_offset = _bloom_filter_offset <- None
    method reset_bloom_filter_offset = _bloom_filter_offset <- None
    val mutable _bloom_filter_length : Int32.t option = None
    method get_bloom_filter_length = _bloom_filter_length

    method grab_bloom_filter_length =
      match _bloom_filter_length with
      | None -> raise (Field_empty "columnMetaData.bloom_filter_length")
      | Some _x303 -> _x303

    method set_bloom_filter_length _x303 = _bloom_filter_length <- Some _x303
    method unset_bloom_filter_length = _bloom_filter_length <- None
    method reset_bloom_filter_length = _bloom_filter_length <- None

    method copy =
      let _new = Oo.copy self in
      if _key_value_metadata <> None then
        _new#set_key_value_metadata
          (List.map (fun x -> x#copy) self#grab_key_value_metadata);
      if _statistics <> None then _new#set_statistics self#grab_statistics#copy;
      if _encoding_stats <> None then
        _new#set_encoding_stats
          (List.map (fun x -> x#copy) self#grab_encoding_stats);
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "ColumnMetaData";
      (match _type with
      | None -> raise (Field_empty "columnMetaData._type")
      | Some _v ->
          oprot#writeFieldBegin ("type", Protocol.T_I32, 1);
          oprot#writeI32 (Type.to_i _v);
          oprot#writeFieldEnd);
      (match _encodings with
      | None -> raise (Field_empty "columnMetaData._encodings")
      | Some _v ->
          oprot#writeFieldBegin ("encodings", Protocol.T_LIST, 2);
          oprot#writeListBegin (Protocol.T_I32, List.length _v);
          List.iter (fun _iter306 -> oprot#writeI32 (Encoding.to_i _iter306)) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _path_in_schema with
      | None -> raise (Field_empty "columnMetaData._path_in_schema")
      | Some _v ->
          oprot#writeFieldBegin ("path_in_schema", Protocol.T_LIST, 3);
          oprot#writeListBegin (Protocol.T_STRING, List.length _v);
          List.iter (fun _iter307 -> oprot#writeString _iter307) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _codec with
      | None -> raise (Field_empty "columnMetaData._codec")
      | Some _v ->
          oprot#writeFieldBegin ("codec", Protocol.T_I32, 4);
          oprot#writeI32 (CompressionCodec.to_i _v);
          oprot#writeFieldEnd);
      (match _num_values with
      | None -> raise (Field_empty "columnMetaData._num_values")
      | Some _v ->
          oprot#writeFieldBegin ("num_values", Protocol.T_I64, 5);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _total_uncompressed_size with
      | None -> raise (Field_empty "columnMetaData._total_uncompressed_size")
      | Some _v ->
          oprot#writeFieldBegin ("total_uncompressed_size", Protocol.T_I64, 6);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _total_compressed_size with
      | None -> raise (Field_empty "columnMetaData._total_compressed_size")
      | Some _v ->
          oprot#writeFieldBegin ("total_compressed_size", Protocol.T_I64, 7);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _key_value_metadata with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("key_value_metadata", Protocol.T_LIST, 8);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter308 -> _iter308#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _data_page_offset with
      | None -> raise (Field_empty "columnMetaData._data_page_offset")
      | Some _v ->
          oprot#writeFieldBegin ("data_page_offset", Protocol.T_I64, 9);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _index_page_offset with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("index_page_offset", Protocol.T_I64, 10);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _dictionary_page_offset with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("dictionary_page_offset", Protocol.T_I64, 11);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _statistics with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("statistics", Protocol.T_STRUCT, 12);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _encoding_stats with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("encoding_stats", Protocol.T_LIST, 13);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter309 -> _iter309#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _bloom_filter_offset with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("bloom_filter_offset", Protocol.T_I64, 14);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _bloom_filter_length with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("bloom_filter_length", Protocol.T_I32, 15);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_columnMetaData (iprot : Protocol.t) =
  let _str310 = new columnMetaData in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t311, _id312 = iprot#readFieldBegin in
       if _t311 = Protocol.T_STOP then raise Break else ();
       (match _id312 with
       | 1 ->
           if _t311 = Protocol.T_I32 then
             _str310#set_type (Type.of_i iprot#readI32)
           else iprot#skip _t311
       | 2 ->
           if _t311 = Protocol.T_LIST then
             _str310#set_encodings
               (let _etype316, _size313 = iprot#readListBegin in
                let _con317 =
                  Array.to_list
                    (Array.init _size313 (fun _ -> Encoding.of_i iprot#readI32))
                in
                iprot#readListEnd;
                _con317)
           else iprot#skip _t311
       | 3 ->
           if _t311 = Protocol.T_LIST then
             _str310#set_path_in_schema
               (let _etype321, _size318 = iprot#readListBegin in
                let _con322 =
                  Array.to_list
                    (Array.init _size318 (fun _ -> iprot#readString))
                in
                iprot#readListEnd;
                _con322)
           else iprot#skip _t311
       | 4 ->
           if _t311 = Protocol.T_I32 then
             _str310#set_codec (CompressionCodec.of_i iprot#readI32)
           else iprot#skip _t311
       | 5 ->
           if _t311 = Protocol.T_I64 then _str310#set_num_values iprot#readI64
           else iprot#skip _t311
       | 6 ->
           if _t311 = Protocol.T_I64 then
             _str310#set_total_uncompressed_size iprot#readI64
           else iprot#skip _t311
       | 7 ->
           if _t311 = Protocol.T_I64 then
             _str310#set_total_compressed_size iprot#readI64
           else iprot#skip _t311
       | 8 ->
           if _t311 = Protocol.T_LIST then
             _str310#set_key_value_metadata
               (let _etype326, _size323 = iprot#readListBegin in
                let _con327 =
                  Array.to_list
                    (Array.init _size323 (fun _ -> read_keyValue iprot))
                in
                iprot#readListEnd;
                _con327)
           else iprot#skip _t311
       | 9 ->
           if _t311 = Protocol.T_I64 then
             _str310#set_data_page_offset iprot#readI64
           else iprot#skip _t311
       | 10 ->
           if _t311 = Protocol.T_I64 then
             _str310#set_index_page_offset iprot#readI64
           else iprot#skip _t311
       | 11 ->
           if _t311 = Protocol.T_I64 then
             _str310#set_dictionary_page_offset iprot#readI64
           else iprot#skip _t311
       | 12 ->
           if _t311 = Protocol.T_STRUCT then
             _str310#set_statistics (read_statistics iprot)
           else iprot#skip _t311
       | 13 ->
           if _t311 = Protocol.T_LIST then
             _str310#set_encoding_stats
               (let _etype331, _size328 = iprot#readListBegin in
                let _con332 =
                  Array.to_list
                    (Array.init _size328 (fun _ -> read_pageEncodingStats iprot))
                in
                iprot#readListEnd;
                _con332)
           else iprot#skip _t311
       | 14 ->
           if _t311 = Protocol.T_I64 then
             _str310#set_bloom_filter_offset iprot#readI64
           else iprot#skip _t311
       | 15 ->
           if _t311 = Protocol.T_I32 then
             _str310#set_bloom_filter_length iprot#readI32
           else iprot#skip _t311
       | _ -> iprot#skip _t311);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str310

class encryptionWithFooterKey =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "EncryptionWithFooterKey";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_encryptionWithFooterKey (iprot : Protocol.t) =
  let _str336 = new encryptionWithFooterKey in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t337, _id338 = iprot#readFieldBegin in
       if _t337 = Protocol.T_STOP then raise Break else ();
       (match _id338 with _ -> iprot#skip _t337);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str336

class encryptionWithColumnKey =
  object (self)
    val mutable _path_in_schema : string list option = None
    method get_path_in_schema = _path_in_schema

    method grab_path_in_schema =
      match _path_in_schema with
      | None -> raise (Field_empty "encryptionWithColumnKey.path_in_schema")
      | Some _x340 -> _x340

    method set_path_in_schema _x340 = _path_in_schema <- Some _x340
    method unset_path_in_schema = _path_in_schema <- None
    method reset_path_in_schema = _path_in_schema <- None
    val mutable _key_metadata : string option = None
    method get_key_metadata = _key_metadata

    method grab_key_metadata =
      match _key_metadata with
      | None -> raise (Field_empty "encryptionWithColumnKey.key_metadata")
      | Some _x341 -> _x341

    method set_key_metadata _x341 = _key_metadata <- Some _x341
    method unset_key_metadata = _key_metadata <- None
    method reset_key_metadata = _key_metadata <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "EncryptionWithColumnKey";
      (match _path_in_schema with
      | None -> raise (Field_empty "encryptionWithColumnKey._path_in_schema")
      | Some _v ->
          oprot#writeFieldBegin ("path_in_schema", Protocol.T_LIST, 1);
          oprot#writeListBegin (Protocol.T_STRING, List.length _v);
          List.iter (fun _iter344 -> oprot#writeString _iter344) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _key_metadata with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("key_metadata", Protocol.T_STRING, 2);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_encryptionWithColumnKey (iprot : Protocol.t) =
  let _str345 = new encryptionWithColumnKey in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t346, _id347 = iprot#readFieldBegin in
       if _t346 = Protocol.T_STOP then raise Break else ();
       (match _id347 with
       | 1 ->
           if _t346 = Protocol.T_LIST then
             _str345#set_path_in_schema
               (let _etype351, _size348 = iprot#readListBegin in
                let _con352 =
                  Array.to_list
                    (Array.init _size348 (fun _ -> iprot#readString))
                in
                iprot#readListEnd;
                _con352)
           else iprot#skip _t346
       | 2 ->
           if _t346 = Protocol.T_STRING then
             _str345#set_key_metadata iprot#readString
           else iprot#skip _t346
       | _ -> iprot#skip _t346);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str345

class columnCryptoMetaData =
  object (self)
    val mutable _eNCRYPTION_WITH_FOOTER_KEY : encryptionWithFooterKey option =
      None

    method get_eNCRYPTION_WITH_FOOTER_KEY = _eNCRYPTION_WITH_FOOTER_KEY

    method grab_eNCRYPTION_WITH_FOOTER_KEY =
      match _eNCRYPTION_WITH_FOOTER_KEY with
      | None ->
          raise (Field_empty "columnCryptoMetaData.eNCRYPTION_WITH_FOOTER_KEY")
      | Some _x354 -> _x354

    method set_eNCRYPTION_WITH_FOOTER_KEY _x354 =
      _eNCRYPTION_WITH_FOOTER_KEY <- Some _x354

    method unset_eNCRYPTION_WITH_FOOTER_KEY =
      _eNCRYPTION_WITH_FOOTER_KEY <- None

    method reset_eNCRYPTION_WITH_FOOTER_KEY =
      _eNCRYPTION_WITH_FOOTER_KEY <- None

    val mutable _eNCRYPTION_WITH_COLUMN_KEY : encryptionWithColumnKey option =
      None

    method get_eNCRYPTION_WITH_COLUMN_KEY = _eNCRYPTION_WITH_COLUMN_KEY

    method grab_eNCRYPTION_WITH_COLUMN_KEY =
      match _eNCRYPTION_WITH_COLUMN_KEY with
      | None ->
          raise (Field_empty "columnCryptoMetaData.eNCRYPTION_WITH_COLUMN_KEY")
      | Some _x355 -> _x355

    method set_eNCRYPTION_WITH_COLUMN_KEY _x355 =
      _eNCRYPTION_WITH_COLUMN_KEY <- Some _x355

    method unset_eNCRYPTION_WITH_COLUMN_KEY =
      _eNCRYPTION_WITH_COLUMN_KEY <- None

    method reset_eNCRYPTION_WITH_COLUMN_KEY =
      _eNCRYPTION_WITH_COLUMN_KEY <- None

    method copy =
      let _new = Oo.copy self in
      if _eNCRYPTION_WITH_FOOTER_KEY <> None then
        _new#set_eNCRYPTION_WITH_FOOTER_KEY
          self#grab_eNCRYPTION_WITH_FOOTER_KEY#copy;
      if _eNCRYPTION_WITH_COLUMN_KEY <> None then
        _new#set_eNCRYPTION_WITH_COLUMN_KEY
          self#grab_eNCRYPTION_WITH_COLUMN_KEY#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "ColumnCryptoMetaData";
      (match _eNCRYPTION_WITH_FOOTER_KEY with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin
            ("ENCRYPTION_WITH_FOOTER_KEY", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _eNCRYPTION_WITH_COLUMN_KEY with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin
            ("ENCRYPTION_WITH_COLUMN_KEY", Protocol.T_STRUCT, 2);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_columnCryptoMetaData (iprot : Protocol.t) =
  let _str358 = new columnCryptoMetaData in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t359, _id360 = iprot#readFieldBegin in
       if _t359 = Protocol.T_STOP then raise Break else ();
       (match _id360 with
       | 1 ->
           if _t359 = Protocol.T_STRUCT then
             _str358#set_eNCRYPTION_WITH_FOOTER_KEY
               (read_encryptionWithFooterKey iprot)
           else iprot#skip _t359
       | 2 ->
           if _t359 = Protocol.T_STRUCT then
             _str358#set_eNCRYPTION_WITH_COLUMN_KEY
               (read_encryptionWithColumnKey iprot)
           else iprot#skip _t359
       | _ -> iprot#skip _t359);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str358

class columnChunk =
  object (self)
    val mutable _file_path : string option = None
    method get_file_path = _file_path

    method grab_file_path =
      match _file_path with
      | None -> raise (Field_empty "columnChunk.file_path")
      | Some _x362 -> _x362

    method set_file_path _x362 = _file_path <- Some _x362
    method unset_file_path = _file_path <- None
    method reset_file_path = _file_path <- None
    val mutable _file_offset : Int64.t option = None
    method get_file_offset = _file_offset

    method grab_file_offset =
      match _file_offset with
      | None -> raise (Field_empty "columnChunk.file_offset")
      | Some _x363 -> _x363

    method set_file_offset _x363 = _file_offset <- Some _x363
    method unset_file_offset = _file_offset <- None
    method reset_file_offset = _file_offset <- None
    val mutable _meta_data : columnMetaData option = None
    method get_meta_data = _meta_data

    method grab_meta_data =
      match _meta_data with
      | None -> raise (Field_empty "columnChunk.meta_data")
      | Some _x364 -> _x364

    method set_meta_data _x364 = _meta_data <- Some _x364
    method unset_meta_data = _meta_data <- None
    method reset_meta_data = _meta_data <- None
    val mutable _offset_index_offset : Int64.t option = None
    method get_offset_index_offset = _offset_index_offset

    method grab_offset_index_offset =
      match _offset_index_offset with
      | None -> raise (Field_empty "columnChunk.offset_index_offset")
      | Some _x365 -> _x365

    method set_offset_index_offset _x365 = _offset_index_offset <- Some _x365
    method unset_offset_index_offset = _offset_index_offset <- None
    method reset_offset_index_offset = _offset_index_offset <- None
    val mutable _offset_index_length : Int32.t option = None
    method get_offset_index_length = _offset_index_length

    method grab_offset_index_length =
      match _offset_index_length with
      | None -> raise (Field_empty "columnChunk.offset_index_length")
      | Some _x366 -> _x366

    method set_offset_index_length _x366 = _offset_index_length <- Some _x366
    method unset_offset_index_length = _offset_index_length <- None
    method reset_offset_index_length = _offset_index_length <- None
    val mutable _column_index_offset : Int64.t option = None
    method get_column_index_offset = _column_index_offset

    method grab_column_index_offset =
      match _column_index_offset with
      | None -> raise (Field_empty "columnChunk.column_index_offset")
      | Some _x367 -> _x367

    method set_column_index_offset _x367 = _column_index_offset <- Some _x367
    method unset_column_index_offset = _column_index_offset <- None
    method reset_column_index_offset = _column_index_offset <- None
    val mutable _column_index_length : Int32.t option = None
    method get_column_index_length = _column_index_length

    method grab_column_index_length =
      match _column_index_length with
      | None -> raise (Field_empty "columnChunk.column_index_length")
      | Some _x368 -> _x368

    method set_column_index_length _x368 = _column_index_length <- Some _x368
    method unset_column_index_length = _column_index_length <- None
    method reset_column_index_length = _column_index_length <- None
    val mutable _crypto_metadata : columnCryptoMetaData option = None
    method get_crypto_metadata = _crypto_metadata

    method grab_crypto_metadata =
      match _crypto_metadata with
      | None -> raise (Field_empty "columnChunk.crypto_metadata")
      | Some _x369 -> _x369

    method set_crypto_metadata _x369 = _crypto_metadata <- Some _x369
    method unset_crypto_metadata = _crypto_metadata <- None
    method reset_crypto_metadata = _crypto_metadata <- None
    val mutable _encrypted_column_metadata : string option = None
    method get_encrypted_column_metadata = _encrypted_column_metadata

    method grab_encrypted_column_metadata =
      match _encrypted_column_metadata with
      | None -> raise (Field_empty "columnChunk.encrypted_column_metadata")
      | Some _x370 -> _x370

    method set_encrypted_column_metadata _x370 =
      _encrypted_column_metadata <- Some _x370

    method unset_encrypted_column_metadata = _encrypted_column_metadata <- None
    method reset_encrypted_column_metadata = _encrypted_column_metadata <- None

    method copy =
      let _new = Oo.copy self in
      if _meta_data <> None then _new#set_meta_data self#grab_meta_data#copy;
      if _crypto_metadata <> None then
        _new#set_crypto_metadata self#grab_crypto_metadata#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "ColumnChunk";
      (match _file_path with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("file_path", Protocol.T_STRING, 1);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _file_offset with
      | None -> raise (Field_empty "columnChunk._file_offset")
      | Some _v ->
          oprot#writeFieldBegin ("file_offset", Protocol.T_I64, 2);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _meta_data with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("meta_data", Protocol.T_STRUCT, 3);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _offset_index_offset with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("offset_index_offset", Protocol.T_I64, 4);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _offset_index_length with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("offset_index_length", Protocol.T_I32, 5);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _column_index_offset with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("column_index_offset", Protocol.T_I64, 6);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _column_index_length with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("column_index_length", Protocol.T_I32, 7);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _crypto_metadata with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("crypto_metadata", Protocol.T_STRUCT, 8);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _encrypted_column_metadata with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin
            ("encrypted_column_metadata", Protocol.T_STRING, 9);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_columnChunk (iprot : Protocol.t) =
  let _str373 = new columnChunk in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t374, _id375 = iprot#readFieldBegin in
       if _t374 = Protocol.T_STOP then raise Break else ();
       (match _id375 with
       | 1 ->
           if _t374 = Protocol.T_STRING then
             _str373#set_file_path iprot#readString
           else iprot#skip _t374
       | 2 ->
           if _t374 = Protocol.T_I64 then _str373#set_file_offset iprot#readI64
           else iprot#skip _t374
       | 3 ->
           if _t374 = Protocol.T_STRUCT then
             _str373#set_meta_data (read_columnMetaData iprot)
           else iprot#skip _t374
       | 4 ->
           if _t374 = Protocol.T_I64 then
             _str373#set_offset_index_offset iprot#readI64
           else iprot#skip _t374
       | 5 ->
           if _t374 = Protocol.T_I32 then
             _str373#set_offset_index_length iprot#readI32
           else iprot#skip _t374
       | 6 ->
           if _t374 = Protocol.T_I64 then
             _str373#set_column_index_offset iprot#readI64
           else iprot#skip _t374
       | 7 ->
           if _t374 = Protocol.T_I32 then
             _str373#set_column_index_length iprot#readI32
           else iprot#skip _t374
       | 8 ->
           if _t374 = Protocol.T_STRUCT then
             _str373#set_crypto_metadata (read_columnCryptoMetaData iprot)
           else iprot#skip _t374
       | 9 ->
           if _t374 = Protocol.T_STRING then
             _str373#set_encrypted_column_metadata iprot#readString
           else iprot#skip _t374
       | _ -> iprot#skip _t374);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str373

class rowGroup =
  object (self)
    val mutable _columns : columnChunk list option = None
    method get_columns = _columns

    method grab_columns =
      match _columns with
      | None -> raise (Field_empty "rowGroup.columns")
      | Some _x377 -> _x377

    method set_columns _x377 = _columns <- Some _x377
    method unset_columns = _columns <- None
    method reset_columns = _columns <- None
    val mutable _total_byte_size : Int64.t option = None
    method get_total_byte_size = _total_byte_size

    method grab_total_byte_size =
      match _total_byte_size with
      | None -> raise (Field_empty "rowGroup.total_byte_size")
      | Some _x378 -> _x378

    method set_total_byte_size _x378 = _total_byte_size <- Some _x378
    method unset_total_byte_size = _total_byte_size <- None
    method reset_total_byte_size = _total_byte_size <- None
    val mutable _num_rows : Int64.t option = None
    method get_num_rows = _num_rows

    method grab_num_rows =
      match _num_rows with
      | None -> raise (Field_empty "rowGroup.num_rows")
      | Some _x379 -> _x379

    method set_num_rows _x379 = _num_rows <- Some _x379
    method unset_num_rows = _num_rows <- None
    method reset_num_rows = _num_rows <- None
    val mutable _sorting_columns : sortingColumn list option = None
    method get_sorting_columns = _sorting_columns

    method grab_sorting_columns =
      match _sorting_columns with
      | None -> raise (Field_empty "rowGroup.sorting_columns")
      | Some _x380 -> _x380

    method set_sorting_columns _x380 = _sorting_columns <- Some _x380
    method unset_sorting_columns = _sorting_columns <- None
    method reset_sorting_columns = _sorting_columns <- None
    val mutable _file_offset : Int64.t option = None
    method get_file_offset = _file_offset

    method grab_file_offset =
      match _file_offset with
      | None -> raise (Field_empty "rowGroup.file_offset")
      | Some _x381 -> _x381

    method set_file_offset _x381 = _file_offset <- Some _x381
    method unset_file_offset = _file_offset <- None
    method reset_file_offset = _file_offset <- None
    val mutable _total_compressed_size : Int64.t option = None
    method get_total_compressed_size = _total_compressed_size

    method grab_total_compressed_size =
      match _total_compressed_size with
      | None -> raise (Field_empty "rowGroup.total_compressed_size")
      | Some _x382 -> _x382

    method set_total_compressed_size _x382 =
      _total_compressed_size <- Some _x382

    method unset_total_compressed_size = _total_compressed_size <- None
    method reset_total_compressed_size = _total_compressed_size <- None
    val mutable _ordinal : int option = None
    method get_ordinal = _ordinal

    method grab_ordinal =
      match _ordinal with
      | None -> raise (Field_empty "rowGroup.ordinal")
      | Some _x383 -> _x383

    method set_ordinal _x383 = _ordinal <- Some _x383
    method unset_ordinal = _ordinal <- None
    method reset_ordinal = _ordinal <- None

    method copy =
      let _new = Oo.copy self in
      if _columns <> None then
        _new#set_columns (List.map (fun x -> x#copy) self#grab_columns);
      if _sorting_columns <> None then
        _new#set_sorting_columns
          (List.map (fun x -> x#copy) self#grab_sorting_columns);
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "RowGroup";
      (match _columns with
      | None -> raise (Field_empty "rowGroup._columns")
      | Some _v ->
          oprot#writeFieldBegin ("columns", Protocol.T_LIST, 1);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter386 -> _iter386#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _total_byte_size with
      | None -> raise (Field_empty "rowGroup._total_byte_size")
      | Some _v ->
          oprot#writeFieldBegin ("total_byte_size", Protocol.T_I64, 2);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _num_rows with
      | None -> raise (Field_empty "rowGroup._num_rows")
      | Some _v ->
          oprot#writeFieldBegin ("num_rows", Protocol.T_I64, 3);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _sorting_columns with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("sorting_columns", Protocol.T_LIST, 4);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter387 -> _iter387#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _file_offset with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("file_offset", Protocol.T_I64, 5);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _total_compressed_size with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("total_compressed_size", Protocol.T_I64, 6);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _ordinal with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("ordinal", Protocol.T_I16, 7);
          oprot#writeI16 _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_rowGroup (iprot : Protocol.t) =
  let _str388 = new rowGroup in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t389, _id390 = iprot#readFieldBegin in
       if _t389 = Protocol.T_STOP then raise Break else ();
       (match _id390 with
       | 1 ->
           if _t389 = Protocol.T_LIST then
             _str388#set_columns
               (let _etype394, _size391 = iprot#readListBegin in
                let _con395 =
                  Array.to_list
                    (Array.init _size391 (fun _ -> read_columnChunk iprot))
                in
                iprot#readListEnd;
                _con395)
           else iprot#skip _t389
       | 2 ->
           if _t389 = Protocol.T_I64 then
             _str388#set_total_byte_size iprot#readI64
           else iprot#skip _t389
       | 3 ->
           if _t389 = Protocol.T_I64 then _str388#set_num_rows iprot#readI64
           else iprot#skip _t389
       | 4 ->
           if _t389 = Protocol.T_LIST then
             _str388#set_sorting_columns
               (let _etype399, _size396 = iprot#readListBegin in
                let _con400 =
                  Array.to_list
                    (Array.init _size396 (fun _ -> read_sortingColumn iprot))
                in
                iprot#readListEnd;
                _con400)
           else iprot#skip _t389
       | 5 ->
           if _t389 = Protocol.T_I64 then _str388#set_file_offset iprot#readI64
           else iprot#skip _t389
       | 6 ->
           if _t389 = Protocol.T_I64 then
             _str388#set_total_compressed_size iprot#readI64
           else iprot#skip _t389
       | 7 ->
           if _t389 = Protocol.T_I16 then _str388#set_ordinal iprot#readI16
           else iprot#skip _t389
       | _ -> iprot#skip _t389);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str388

class typeDefinedOrder =
  object (self)
    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "TypeDefinedOrder";
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_typeDefinedOrder (iprot : Protocol.t) =
  let _str404 = new typeDefinedOrder in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t405, _id406 = iprot#readFieldBegin in
       if _t405 = Protocol.T_STOP then raise Break else ();
       (match _id406 with _ -> iprot#skip _t405);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str404

class columnOrder =
  object (self)
    val mutable _tYPE_ORDER : typeDefinedOrder option = None
    method get_tYPE_ORDER = _tYPE_ORDER

    method grab_tYPE_ORDER =
      match _tYPE_ORDER with
      | None -> raise (Field_empty "columnOrder.tYPE_ORDER")
      | Some _x408 -> _x408

    method set_tYPE_ORDER _x408 = _tYPE_ORDER <- Some _x408
    method unset_tYPE_ORDER = _tYPE_ORDER <- None
    method reset_tYPE_ORDER = _tYPE_ORDER <- None

    method copy =
      let _new = Oo.copy self in
      if _tYPE_ORDER <> None then _new#set_tYPE_ORDER self#grab_tYPE_ORDER#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "ColumnOrder";
      (match _tYPE_ORDER with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("TYPE_ORDER", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_columnOrder (iprot : Protocol.t) =
  let _str411 = new columnOrder in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t412, _id413 = iprot#readFieldBegin in
       if _t412 = Protocol.T_STOP then raise Break else ();
       (match _id413 with
       | 1 ->
           if _t412 = Protocol.T_STRUCT then
             _str411#set_tYPE_ORDER (read_typeDefinedOrder iprot)
           else iprot#skip _t412
       | _ -> iprot#skip _t412);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str411

class pageLocation =
  object (self)
    val mutable _offset : Int64.t option = None
    method get_offset = _offset

    method grab_offset =
      match _offset with
      | None -> raise (Field_empty "pageLocation.offset")
      | Some _x415 -> _x415

    method set_offset _x415 = _offset <- Some _x415
    method unset_offset = _offset <- None
    method reset_offset = _offset <- None
    val mutable _compressed_page_size : Int32.t option = None
    method get_compressed_page_size = _compressed_page_size

    method grab_compressed_page_size =
      match _compressed_page_size with
      | None -> raise (Field_empty "pageLocation.compressed_page_size")
      | Some _x416 -> _x416

    method set_compressed_page_size _x416 = _compressed_page_size <- Some _x416
    method unset_compressed_page_size = _compressed_page_size <- None
    method reset_compressed_page_size = _compressed_page_size <- None
    val mutable _first_row_index : Int64.t option = None
    method get_first_row_index = _first_row_index

    method grab_first_row_index =
      match _first_row_index with
      | None -> raise (Field_empty "pageLocation.first_row_index")
      | Some _x417 -> _x417

    method set_first_row_index _x417 = _first_row_index <- Some _x417
    method unset_first_row_index = _first_row_index <- None
    method reset_first_row_index = _first_row_index <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "PageLocation";
      (match _offset with
      | None -> raise (Field_empty "pageLocation._offset")
      | Some _v ->
          oprot#writeFieldBegin ("offset", Protocol.T_I64, 1);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _compressed_page_size with
      | None -> raise (Field_empty "pageLocation._compressed_page_size")
      | Some _v ->
          oprot#writeFieldBegin ("compressed_page_size", Protocol.T_I32, 2);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _first_row_index with
      | None -> raise (Field_empty "pageLocation._first_row_index")
      | Some _v ->
          oprot#writeFieldBegin ("first_row_index", Protocol.T_I64, 3);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_pageLocation (iprot : Protocol.t) =
  let _str420 = new pageLocation in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t421, _id422 = iprot#readFieldBegin in
       if _t421 = Protocol.T_STOP then raise Break else ();
       (match _id422 with
       | 1 ->
           if _t421 = Protocol.T_I64 then _str420#set_offset iprot#readI64
           else iprot#skip _t421
       | 2 ->
           if _t421 = Protocol.T_I32 then
             _str420#set_compressed_page_size iprot#readI32
           else iprot#skip _t421
       | 3 ->
           if _t421 = Protocol.T_I64 then
             _str420#set_first_row_index iprot#readI64
           else iprot#skip _t421
       | _ -> iprot#skip _t421);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str420

class offsetIndex =
  object (self)
    val mutable _page_locations : pageLocation list option = None
    method get_page_locations = _page_locations

    method grab_page_locations =
      match _page_locations with
      | None -> raise (Field_empty "offsetIndex.page_locations")
      | Some _x424 -> _x424

    method set_page_locations _x424 = _page_locations <- Some _x424
    method unset_page_locations = _page_locations <- None
    method reset_page_locations = _page_locations <- None

    method copy =
      let _new = Oo.copy self in
      if _page_locations <> None then
        _new#set_page_locations
          (List.map (fun x -> x#copy) self#grab_page_locations);
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "OffsetIndex";
      (match _page_locations with
      | None -> raise (Field_empty "offsetIndex._page_locations")
      | Some _v ->
          oprot#writeFieldBegin ("page_locations", Protocol.T_LIST, 1);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter427 -> _iter427#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_offsetIndex (iprot : Protocol.t) =
  let _str428 = new offsetIndex in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t429, _id430 = iprot#readFieldBegin in
       if _t429 = Protocol.T_STOP then raise Break else ();
       (match _id430 with
       | 1 ->
           if _t429 = Protocol.T_LIST then
             _str428#set_page_locations
               (let _etype434, _size431 = iprot#readListBegin in
                let _con435 =
                  Array.to_list
                    (Array.init _size431 (fun _ -> read_pageLocation iprot))
                in
                iprot#readListEnd;
                _con435)
           else iprot#skip _t429
       | _ -> iprot#skip _t429);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str428

class columnIndex =
  object (self)
    val mutable _null_pages : bool list option = None
    method get_null_pages = _null_pages

    method grab_null_pages =
      match _null_pages with
      | None -> raise (Field_empty "columnIndex.null_pages")
      | Some _x437 -> _x437

    method set_null_pages _x437 = _null_pages <- Some _x437
    method unset_null_pages = _null_pages <- None
    method reset_null_pages = _null_pages <- None
    val mutable _min_values : string list option = None
    method get_min_values = _min_values

    method grab_min_values =
      match _min_values with
      | None -> raise (Field_empty "columnIndex.min_values")
      | Some _x438 -> _x438

    method set_min_values _x438 = _min_values <- Some _x438
    method unset_min_values = _min_values <- None
    method reset_min_values = _min_values <- None
    val mutable _max_values : string list option = None
    method get_max_values = _max_values

    method grab_max_values =
      match _max_values with
      | None -> raise (Field_empty "columnIndex.max_values")
      | Some _x439 -> _x439

    method set_max_values _x439 = _max_values <- Some _x439
    method unset_max_values = _max_values <- None
    method reset_max_values = _max_values <- None
    val mutable _boundary_order : BoundaryOrder.t option = None
    method get_boundary_order = _boundary_order

    method grab_boundary_order =
      match _boundary_order with
      | None -> raise (Field_empty "columnIndex.boundary_order")
      | Some _x440 -> _x440

    method set_boundary_order _x440 = _boundary_order <- Some _x440
    method unset_boundary_order = _boundary_order <- None
    method reset_boundary_order = _boundary_order <- None
    val mutable _null_counts : Int64.t list option = None
    method get_null_counts = _null_counts

    method grab_null_counts =
      match _null_counts with
      | None -> raise (Field_empty "columnIndex.null_counts")
      | Some _x441 -> _x441

    method set_null_counts _x441 = _null_counts <- Some _x441
    method unset_null_counts = _null_counts <- None
    method reset_null_counts = _null_counts <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "ColumnIndex";
      (match _null_pages with
      | None -> raise (Field_empty "columnIndex._null_pages")
      | Some _v ->
          oprot#writeFieldBegin ("null_pages", Protocol.T_LIST, 1);
          oprot#writeListBegin (Protocol.T_BOOL, List.length _v);
          List.iter (fun _iter444 -> oprot#writeBool _iter444) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _min_values with
      | None -> raise (Field_empty "columnIndex._min_values")
      | Some _v ->
          oprot#writeFieldBegin ("min_values", Protocol.T_LIST, 2);
          oprot#writeListBegin (Protocol.T_STRING, List.length _v);
          List.iter (fun _iter445 -> oprot#writeString _iter445) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _max_values with
      | None -> raise (Field_empty "columnIndex._max_values")
      | Some _v ->
          oprot#writeFieldBegin ("max_values", Protocol.T_LIST, 3);
          oprot#writeListBegin (Protocol.T_STRING, List.length _v);
          List.iter (fun _iter446 -> oprot#writeString _iter446) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _boundary_order with
      | None -> raise (Field_empty "columnIndex._boundary_order")
      | Some _v ->
          oprot#writeFieldBegin ("boundary_order", Protocol.T_I32, 4);
          oprot#writeI32 (BoundaryOrder.to_i _v);
          oprot#writeFieldEnd);
      (match _null_counts with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("null_counts", Protocol.T_LIST, 5);
          oprot#writeListBegin (Protocol.T_I64, List.length _v);
          List.iter (fun _iter447 -> oprot#writeI64 _iter447) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_columnIndex (iprot : Protocol.t) =
  let _str448 = new columnIndex in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t449, _id450 = iprot#readFieldBegin in
       if _t449 = Protocol.T_STOP then raise Break else ();
       (match _id450 with
       | 1 ->
           if _t449 = Protocol.T_LIST then
             _str448#set_null_pages
               (let _etype454, _size451 = iprot#readListBegin in
                let _con455 =
                  Array.to_list (Array.init _size451 (fun _ -> iprot#readBool))
                in
                iprot#readListEnd;
                _con455)
           else iprot#skip _t449
       | 2 ->
           if _t449 = Protocol.T_LIST then
             _str448#set_min_values
               (let _etype459, _size456 = iprot#readListBegin in
                let _con460 =
                  Array.to_list
                    (Array.init _size456 (fun _ -> iprot#readString))
                in
                iprot#readListEnd;
                _con460)
           else iprot#skip _t449
       | 3 ->
           if _t449 = Protocol.T_LIST then
             _str448#set_max_values
               (let _etype464, _size461 = iprot#readListBegin in
                let _con465 =
                  Array.to_list
                    (Array.init _size461 (fun _ -> iprot#readString))
                in
                iprot#readListEnd;
                _con465)
           else iprot#skip _t449
       | 4 ->
           if _t449 = Protocol.T_I32 then
             _str448#set_boundary_order (BoundaryOrder.of_i iprot#readI32)
           else iprot#skip _t449
       | 5 ->
           if _t449 = Protocol.T_LIST then
             _str448#set_null_counts
               (let _etype469, _size466 = iprot#readListBegin in
                let _con470 =
                  Array.to_list (Array.init _size466 (fun _ -> iprot#readI64))
                in
                iprot#readListEnd;
                _con470)
           else iprot#skip _t449
       | _ -> iprot#skip _t449);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str448

class aesGcmV1 =
  object (self)
    val mutable _aad_prefix : string option = None
    method get_aad_prefix = _aad_prefix

    method grab_aad_prefix =
      match _aad_prefix with
      | None -> raise (Field_empty "aesGcmV1.aad_prefix")
      | Some _x472 -> _x472

    method set_aad_prefix _x472 = _aad_prefix <- Some _x472
    method unset_aad_prefix = _aad_prefix <- None
    method reset_aad_prefix = _aad_prefix <- None
    val mutable _aad_file_unique : string option = None
    method get_aad_file_unique = _aad_file_unique

    method grab_aad_file_unique =
      match _aad_file_unique with
      | None -> raise (Field_empty "aesGcmV1.aad_file_unique")
      | Some _x473 -> _x473

    method set_aad_file_unique _x473 = _aad_file_unique <- Some _x473
    method unset_aad_file_unique = _aad_file_unique <- None
    method reset_aad_file_unique = _aad_file_unique <- None
    val mutable _supply_aad_prefix : bool option = None
    method get_supply_aad_prefix = _supply_aad_prefix

    method grab_supply_aad_prefix =
      match _supply_aad_prefix with
      | None -> raise (Field_empty "aesGcmV1.supply_aad_prefix")
      | Some _x474 -> _x474

    method set_supply_aad_prefix _x474 = _supply_aad_prefix <- Some _x474
    method unset_supply_aad_prefix = _supply_aad_prefix <- None
    method reset_supply_aad_prefix = _supply_aad_prefix <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "AesGcmV1";
      (match _aad_prefix with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("aad_prefix", Protocol.T_STRING, 1);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _aad_file_unique with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("aad_file_unique", Protocol.T_STRING, 2);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _supply_aad_prefix with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("supply_aad_prefix", Protocol.T_BOOL, 3);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_aesGcmV1 (iprot : Protocol.t) =
  let _str477 = new aesGcmV1 in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t478, _id479 = iprot#readFieldBegin in
       if _t478 = Protocol.T_STOP then raise Break else ();
       (match _id479 with
       | 1 ->
           if _t478 = Protocol.T_STRING then
             _str477#set_aad_prefix iprot#readString
           else iprot#skip _t478
       | 2 ->
           if _t478 = Protocol.T_STRING then
             _str477#set_aad_file_unique iprot#readString
           else iprot#skip _t478
       | 3 ->
           if _t478 = Protocol.T_BOOL then
             _str477#set_supply_aad_prefix iprot#readBool
           else iprot#skip _t478
       | _ -> iprot#skip _t478);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str477

class aesGcmCtrV1 =
  object (self)
    val mutable _aad_prefix : string option = None
    method get_aad_prefix = _aad_prefix

    method grab_aad_prefix =
      match _aad_prefix with
      | None -> raise (Field_empty "aesGcmCtrV1.aad_prefix")
      | Some _x481 -> _x481

    method set_aad_prefix _x481 = _aad_prefix <- Some _x481
    method unset_aad_prefix = _aad_prefix <- None
    method reset_aad_prefix = _aad_prefix <- None
    val mutable _aad_file_unique : string option = None
    method get_aad_file_unique = _aad_file_unique

    method grab_aad_file_unique =
      match _aad_file_unique with
      | None -> raise (Field_empty "aesGcmCtrV1.aad_file_unique")
      | Some _x482 -> _x482

    method set_aad_file_unique _x482 = _aad_file_unique <- Some _x482
    method unset_aad_file_unique = _aad_file_unique <- None
    method reset_aad_file_unique = _aad_file_unique <- None
    val mutable _supply_aad_prefix : bool option = None
    method get_supply_aad_prefix = _supply_aad_prefix

    method grab_supply_aad_prefix =
      match _supply_aad_prefix with
      | None -> raise (Field_empty "aesGcmCtrV1.supply_aad_prefix")
      | Some _x483 -> _x483

    method set_supply_aad_prefix _x483 = _supply_aad_prefix <- Some _x483
    method unset_supply_aad_prefix = _supply_aad_prefix <- None
    method reset_supply_aad_prefix = _supply_aad_prefix <- None

    method copy =
      let _new = Oo.copy self in
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "AesGcmCtrV1";
      (match _aad_prefix with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("aad_prefix", Protocol.T_STRING, 1);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _aad_file_unique with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("aad_file_unique", Protocol.T_STRING, 2);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _supply_aad_prefix with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("supply_aad_prefix", Protocol.T_BOOL, 3);
          oprot#writeBool _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_aesGcmCtrV1 (iprot : Protocol.t) =
  let _str486 = new aesGcmCtrV1 in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t487, _id488 = iprot#readFieldBegin in
       if _t487 = Protocol.T_STOP then raise Break else ();
       (match _id488 with
       | 1 ->
           if _t487 = Protocol.T_STRING then
             _str486#set_aad_prefix iprot#readString
           else iprot#skip _t487
       | 2 ->
           if _t487 = Protocol.T_STRING then
             _str486#set_aad_file_unique iprot#readString
           else iprot#skip _t487
       | 3 ->
           if _t487 = Protocol.T_BOOL then
             _str486#set_supply_aad_prefix iprot#readBool
           else iprot#skip _t487
       | _ -> iprot#skip _t487);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str486

class encryptionAlgorithm =
  object (self)
    val mutable _aES_GCM_V1 : aesGcmV1 option = None
    method get_aES_GCM_V1 = _aES_GCM_V1

    method grab_aES_GCM_V1 =
      match _aES_GCM_V1 with
      | None -> raise (Field_empty "encryptionAlgorithm.aES_GCM_V1")
      | Some _x490 -> _x490

    method set_aES_GCM_V1 _x490 = _aES_GCM_V1 <- Some _x490
    method unset_aES_GCM_V1 = _aES_GCM_V1 <- None
    method reset_aES_GCM_V1 = _aES_GCM_V1 <- None
    val mutable _aES_GCM_CTR_V1 : aesGcmCtrV1 option = None
    method get_aES_GCM_CTR_V1 = _aES_GCM_CTR_V1

    method grab_aES_GCM_CTR_V1 =
      match _aES_GCM_CTR_V1 with
      | None -> raise (Field_empty "encryptionAlgorithm.aES_GCM_CTR_V1")
      | Some _x491 -> _x491

    method set_aES_GCM_CTR_V1 _x491 = _aES_GCM_CTR_V1 <- Some _x491
    method unset_aES_GCM_CTR_V1 = _aES_GCM_CTR_V1 <- None
    method reset_aES_GCM_CTR_V1 = _aES_GCM_CTR_V1 <- None

    method copy =
      let _new = Oo.copy self in
      if _aES_GCM_V1 <> None then _new#set_aES_GCM_V1 self#grab_aES_GCM_V1#copy;
      if _aES_GCM_CTR_V1 <> None then
        _new#set_aES_GCM_CTR_V1 self#grab_aES_GCM_CTR_V1#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "EncryptionAlgorithm";
      (match _aES_GCM_V1 with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("AES_GCM_V1", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _aES_GCM_CTR_V1 with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("AES_GCM_CTR_V1", Protocol.T_STRUCT, 2);
          _v#write oprot;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_encryptionAlgorithm (iprot : Protocol.t) =
  let _str494 = new encryptionAlgorithm in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t495, _id496 = iprot#readFieldBegin in
       if _t495 = Protocol.T_STOP then raise Break else ();
       (match _id496 with
       | 1 ->
           if _t495 = Protocol.T_STRUCT then
             _str494#set_aES_GCM_V1 (read_aesGcmV1 iprot)
           else iprot#skip _t495
       | 2 ->
           if _t495 = Protocol.T_STRUCT then
             _str494#set_aES_GCM_CTR_V1 (read_aesGcmCtrV1 iprot)
           else iprot#skip _t495
       | _ -> iprot#skip _t495);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str494

class fileMetaData =
  object (self)
    val mutable _version : Int32.t option = None
    method get_version = _version

    method grab_version =
      match _version with
      | None -> raise (Field_empty "fileMetaData.version")
      | Some _x498 -> _x498

    method set_version _x498 = _version <- Some _x498
    method unset_version = _version <- None
    method reset_version = _version <- None
    val mutable _schema : schemaElement list option = None
    method get_schema = _schema

    method grab_schema =
      match _schema with
      | None -> raise (Field_empty "fileMetaData.schema")
      | Some _x499 -> _x499

    method set_schema _x499 = _schema <- Some _x499
    method unset_schema = _schema <- None
    method reset_schema = _schema <- None
    val mutable _num_rows : Int64.t option = None
    method get_num_rows = _num_rows

    method grab_num_rows =
      match _num_rows with
      | None -> raise (Field_empty "fileMetaData.num_rows")
      | Some _x500 -> _x500

    method set_num_rows _x500 = _num_rows <- Some _x500
    method unset_num_rows = _num_rows <- None
    method reset_num_rows = _num_rows <- None
    val mutable _row_groups : rowGroup list option = None
    method get_row_groups = _row_groups

    method grab_row_groups =
      match _row_groups with
      | None -> raise (Field_empty "fileMetaData.row_groups")
      | Some _x501 -> _x501

    method set_row_groups _x501 = _row_groups <- Some _x501
    method unset_row_groups = _row_groups <- None
    method reset_row_groups = _row_groups <- None
    val mutable _key_value_metadata : keyValue list option = None
    method get_key_value_metadata = _key_value_metadata

    method grab_key_value_metadata =
      match _key_value_metadata with
      | None -> raise (Field_empty "fileMetaData.key_value_metadata")
      | Some _x502 -> _x502

    method set_key_value_metadata _x502 = _key_value_metadata <- Some _x502
    method unset_key_value_metadata = _key_value_metadata <- None
    method reset_key_value_metadata = _key_value_metadata <- None
    val mutable _created_by : string option = None
    method get_created_by = _created_by

    method grab_created_by =
      match _created_by with
      | None -> raise (Field_empty "fileMetaData.created_by")
      | Some _x503 -> _x503

    method set_created_by _x503 = _created_by <- Some _x503
    method unset_created_by = _created_by <- None
    method reset_created_by = _created_by <- None
    val mutable _column_orders : columnOrder list option = None
    method get_column_orders = _column_orders

    method grab_column_orders =
      match _column_orders with
      | None -> raise (Field_empty "fileMetaData.column_orders")
      | Some _x504 -> _x504

    method set_column_orders _x504 = _column_orders <- Some _x504
    method unset_column_orders = _column_orders <- None
    method reset_column_orders = _column_orders <- None
    val mutable _encryption_algorithm : encryptionAlgorithm option = None
    method get_encryption_algorithm = _encryption_algorithm

    method grab_encryption_algorithm =
      match _encryption_algorithm with
      | None -> raise (Field_empty "fileMetaData.encryption_algorithm")
      | Some _x505 -> _x505

    method set_encryption_algorithm _x505 = _encryption_algorithm <- Some _x505
    method unset_encryption_algorithm = _encryption_algorithm <- None
    method reset_encryption_algorithm = _encryption_algorithm <- None
    val mutable _footer_signing_key_metadata : string option = None
    method get_footer_signing_key_metadata = _footer_signing_key_metadata

    method grab_footer_signing_key_metadata =
      match _footer_signing_key_metadata with
      | None -> raise (Field_empty "fileMetaData.footer_signing_key_metadata")
      | Some _x506 -> _x506

    method set_footer_signing_key_metadata _x506 =
      _footer_signing_key_metadata <- Some _x506

    method unset_footer_signing_key_metadata =
      _footer_signing_key_metadata <- None

    method reset_footer_signing_key_metadata =
      _footer_signing_key_metadata <- None

    method copy =
      let _new = Oo.copy self in
      if _schema <> None then
        _new#set_schema (List.map (fun x -> x#copy) self#grab_schema);
      if _row_groups <> None then
        _new#set_row_groups (List.map (fun x -> x#copy) self#grab_row_groups);
      if _key_value_metadata <> None then
        _new#set_key_value_metadata
          (List.map (fun x -> x#copy) self#grab_key_value_metadata);
      if _column_orders <> None then
        _new#set_column_orders
          (List.map (fun x -> x#copy) self#grab_column_orders);
      if _encryption_algorithm <> None then
        _new#set_encryption_algorithm self#grab_encryption_algorithm#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "FileMetaData";
      (match _version with
      | None -> raise (Field_empty "fileMetaData._version")
      | Some _v ->
          oprot#writeFieldBegin ("version", Protocol.T_I32, 1);
          oprot#writeI32 _v;
          oprot#writeFieldEnd);
      (match _schema with
      | None -> raise (Field_empty "fileMetaData._schema")
      | Some _v ->
          oprot#writeFieldBegin ("schema", Protocol.T_LIST, 2);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter509 -> _iter509#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _num_rows with
      | None -> raise (Field_empty "fileMetaData._num_rows")
      | Some _v ->
          oprot#writeFieldBegin ("num_rows", Protocol.T_I64, 3);
          oprot#writeI64 _v;
          oprot#writeFieldEnd);
      (match _row_groups with
      | None -> raise (Field_empty "fileMetaData._row_groups")
      | Some _v ->
          oprot#writeFieldBegin ("row_groups", Protocol.T_LIST, 4);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter510 -> _iter510#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _key_value_metadata with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("key_value_metadata", Protocol.T_LIST, 5);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter511 -> _iter511#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _created_by with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("created_by", Protocol.T_STRING, 6);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      (match _column_orders with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("column_orders", Protocol.T_LIST, 7);
          oprot#writeListBegin (Protocol.T_STRUCT, List.length _v);
          List.iter (fun _iter512 -> _iter512#write oprot) _v;
          oprot#writeListEnd;
          oprot#writeFieldEnd);
      (match _encryption_algorithm with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("encryption_algorithm", Protocol.T_STRUCT, 8);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _footer_signing_key_metadata with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin
            ("footer_signing_key_metadata", Protocol.T_STRING, 9);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_fileMetaData (iprot : Protocol.t) =
  let _str513 = new fileMetaData in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t514, _id515 = iprot#readFieldBegin in
       if _t514 = Protocol.T_STOP then raise Break else ();
       (match _id515 with
       | 1 ->
           if _t514 = Protocol.T_I32 then _str513#set_version iprot#readI32
           else iprot#skip _t514
       | 2 ->
           if _t514 = Protocol.T_LIST then
             _str513#set_schema
               (let _etype519, _size516 = iprot#readListBegin in
                let _con520 =
                  Array.to_list
                    (Array.init _size516 (fun _ -> read_schemaElement iprot))
                in
                iprot#readListEnd;
                _con520)
           else iprot#skip _t514
       | 3 ->
           if _t514 = Protocol.T_I64 then _str513#set_num_rows iprot#readI64
           else iprot#skip _t514
       | 4 ->
           if _t514 = Protocol.T_LIST then
             _str513#set_row_groups
               (let _etype524, _size521 = iprot#readListBegin in
                let _con525 =
                  Array.to_list
                    (Array.init _size521 (fun _ -> read_rowGroup iprot))
                in
                iprot#readListEnd;
                _con525)
           else iprot#skip _t514
       | 5 ->
           if _t514 = Protocol.T_LIST then
             _str513#set_key_value_metadata
               (let _etype529, _size526 = iprot#readListBegin in
                let _con530 =
                  Array.to_list
                    (Array.init _size526 (fun _ -> read_keyValue iprot))
                in
                iprot#readListEnd;
                _con530)
           else iprot#skip _t514
       | 6 ->
           if _t514 = Protocol.T_STRING then
             _str513#set_created_by iprot#readString
           else iprot#skip _t514
       | 7 ->
           if _t514 = Protocol.T_LIST then
             _str513#set_column_orders
               (let _etype534, _size531 = iprot#readListBegin in
                let _con535 =
                  Array.to_list
                    (Array.init _size531 (fun _ -> read_columnOrder iprot))
                in
                iprot#readListEnd;
                _con535)
           else iprot#skip _t514
       | 8 ->
           if _t514 = Protocol.T_STRUCT then
             _str513#set_encryption_algorithm (read_encryptionAlgorithm iprot)
           else iprot#skip _t514
       | 9 ->
           if _t514 = Protocol.T_STRING then
             _str513#set_footer_signing_key_metadata iprot#readString
           else iprot#skip _t514
       | _ -> iprot#skip _t514);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str513

class fileCryptoMetaData =
  object (self)
    val mutable _encryption_algorithm : encryptionAlgorithm option = None
    method get_encryption_algorithm = _encryption_algorithm

    method grab_encryption_algorithm =
      match _encryption_algorithm with
      | None -> raise (Field_empty "fileCryptoMetaData.encryption_algorithm")
      | Some _x537 -> _x537

    method set_encryption_algorithm _x537 = _encryption_algorithm <- Some _x537
    method unset_encryption_algorithm = _encryption_algorithm <- None
    method reset_encryption_algorithm = _encryption_algorithm <- None
    val mutable _key_metadata : string option = None
    method get_key_metadata = _key_metadata

    method grab_key_metadata =
      match _key_metadata with
      | None -> raise (Field_empty "fileCryptoMetaData.key_metadata")
      | Some _x538 -> _x538

    method set_key_metadata _x538 = _key_metadata <- Some _x538
    method unset_key_metadata = _key_metadata <- None
    method reset_key_metadata = _key_metadata <- None

    method copy =
      let _new = Oo.copy self in
      if _encryption_algorithm <> None then
        _new#set_encryption_algorithm self#grab_encryption_algorithm#copy;
      _new

    method write (oprot : Protocol.t) =
      oprot#writeStructBegin "FileCryptoMetaData";
      (match _encryption_algorithm with
      | None -> raise (Field_empty "fileCryptoMetaData._encryption_algorithm")
      | Some _v ->
          oprot#writeFieldBegin ("encryption_algorithm", Protocol.T_STRUCT, 1);
          _v#write oprot;
          oprot#writeFieldEnd);
      (match _key_metadata with
      | None -> ()
      | Some _v ->
          oprot#writeFieldBegin ("key_metadata", Protocol.T_STRING, 2);
          oprot#writeString _v;
          oprot#writeFieldEnd);
      oprot#writeFieldStop;
      oprot#writeStructEnd
  end

let rec read_fileCryptoMetaData (iprot : Protocol.t) =
  let _str541 = new fileCryptoMetaData in
  ignore iprot#readStructBegin;
  (try
     while true do
       let _, _t542, _id543 = iprot#readFieldBegin in
       if _t542 = Protocol.T_STOP then raise Break else ();
       (match _id543 with
       | 1 ->
           if _t542 = Protocol.T_STRUCT then
             _str541#set_encryption_algorithm (read_encryptionAlgorithm iprot)
           else iprot#skip _t542
       | 2 ->
           if _t542 = Protocol.T_STRING then
             _str541#set_key_metadata iprot#readString
           else iprot#skip _t542
       | _ -> iprot#skip _t542);
       iprot#readFieldEnd
     done;
     ()
   with Break -> ());
  iprot#readStructEnd;
  _str541
